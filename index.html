<!DOCTYPE html>
<html lang="en-us">
  <head>
	<meta name="generator" content="Hugo 0.64.1" />
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="linjinbao66">
  <meta name="description" content="打工笔记">
  <meta name="keywords" content="博客 个人 笔记">
  
  
  
  <link rel="canonical" href="https://amrom66.github.io/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           打工笔记
       
  </title>
  <meta name="title" content="打工笔记">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
    <link href="https://amrom66.github.io/index.xml" rel="alternate" type="application/rss+xml" title="打工笔记" />
    <link href="https://amrom66.github.io/index.xml" rel="feed" type="application/rss+xml" title="打工笔记" />
  
  

<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "url": "https:\/\/amrom66.github.io\/",
    "name": "打工笔记",
    "author": {
        "@type": "Person",
        "name": "linjinbao66"
    },
    "description": "打工笔记",
}
</script>
 

</head>

  


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-160203449-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://amrom66.github.io">打工笔记</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">博客</a>
                
                <a class="menu-item" href="/categories/" title="">分类</a>
                
                <a class="menu-item" href="/tags/" title="">标签</a>
                
                <a class="menu-item" href="/2020/about/" title="关于">关于</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;
                <a href="https://amrom66.github.io">打工笔记</a>
            </div>
            <div class="menu-toggle">
                <svg t="1618556759902" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1299" width="16" height="16"><path d="M896 1024h-213.333333a128 128 0 0 1-128-128v-213.333333a128 128 0 0 1 128-128h213.333333a128 128 0 0 1 128 128v213.333333a128 128 0 0 1-128 128z m-213.333333-384a42.666667 42.666667 0 0 0-42.666667 42.666667v213.333333a42.666667 42.666667 0 0 0 42.666667 42.666667h213.333333a42.666667 42.666667 0 0 0 42.666667-42.666667v-213.333333a42.666667 42.666667 0 0 0-42.666667-42.666667z m-341.333334 384H128a128 128 0 0 1-128-128v-213.333333a128 128 0 0 1 128-128h213.333333a128 128 0 0 1 128 128v213.333333a128 128 0 0 1-128 128z m-213.333333-384a42.666667 42.666667 0 0 0-42.666667 42.666667v213.333333a42.666667 42.666667 0 0 0 42.666667 42.666667h213.333333a42.666667 42.666667 0 0 0 42.666667-42.666667v-213.333333a42.666667 42.666667 0 0 0-42.666667-42.666667z m768-170.666667h-213.333333a128 128 0 0 1-128-128V128a128 128 0 0 1 128-128h213.333333a128 128 0 0 1 128 128v213.333333a128 128 0 0 1-128 128z m-213.333333-384a42.666667 42.666667 0 0 0-42.666667 42.666667v213.333333a42.666667 42.666667 0 0 0 42.666667 42.666667h213.333333a42.666667 42.666667 0 0 0 42.666667-42.666667V128a42.666667 42.666667 0 0 0-42.666667-42.666667z m-341.333334 384H128a128 128 0 0 1-128-128V128a128 128 0 0 1 128-128h213.333333a128 128 0 0 1 128 128v213.333333a128 128 0 0 1-128 128zM128 85.333333a42.666667 42.666667 0 0 0-42.666667 42.666667v213.333333a42.666667 42.666667 0 0 0 42.666667 42.666667h213.333333a42.666667 42.666667 0 0 0 42.666667-42.666667V128a42.666667 42.666667 0 0 0-42.666667-42.666667z" p-id="1300"></path></svg>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">博客</a>
                
                <a class="menu-item" href="/categories/" title="">分类</a>
                
                <a class="menu-item" href="/tags/" title="">标签</a>
                
                <a class="menu-item" href="/2020/about/" title="关于">关于</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
  	
  	<div class="post-warp">
	<div class="intro">
    
    
    
    <div class="avatar">
        <a href="/"> <img src="/images/me/touxiang.jpeg"> </a>
    </div>
    
    
    <h2 class="description">
       Across the great wall, we can reach the world
    </h2>
    
 
	</div>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2024/2024-02-26-quicksort/">quick sort</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				快速排序思想  选定pivot中心轴（一般选择最左侧） 将大于pivot的数字放在左侧 将小于pivot的数字放在右侧 递归pivot左侧和右侧的数列  代码实现： public void quickSort(int[] nums) { int length = nums.length; quickSort(nums, 0, length - 1); } public void quickSort(int[] nums, int start, int end) { if (start &gt;= end) { return; } int left = start; int right = end; int pivot = nums[left]; while (left &lt; right) { while (left &lt; right &amp;&amp; nums[right] &gt; pivot) { right--; } if (left &lt; right) { nums[left] = nums[right]; left++; } while (left &lt; right &amp;&amp; nums[left] &lt; pivot) { left++; } if (left &lt; right) { nums[right] = nums[left]; right--; } } nums[left] = pivot; quickSort(nums, start, left - 1); quickSort(nums, left + 1, end); } 
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2024-02-26 itemprop="datePublished">February 26, 2024</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2023/2023-05-04-v2ray-dns/">v2ray-dns-gateway</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				分享一个v2ray旁路网关配置 实现的效果  在路由器中配置dhcp地址为该设备的ip 所有由该路由器分配ip的设备流量全部有该设备接管 该设备为一个普通的Linux设备，安装v2ray即可  config.json { &#34;inbounds&#34;: [ { &#34;tag&#34;: &#34;transparent&#34;, &#34;port&#34;: 12345, &#34;protocol&#34;: &#34;dokodemo-door&#34;, &#34;settings&#34;: { &#34;network&#34;: &#34;tcp,udp&#34;, &#34;followRedirect&#34;: true }, &#34;sniffing&#34;: { &#34;enabled&#34;: true, &#34;destOverride&#34;: [ &#34;http&#34;, &#34;tls&#34; ] }, &#34;streamSettings&#34;: { &#34;sockopt&#34;: { &#34;tproxy&#34;: &#34;tproxy&#34;, &#34;mark&#34;: 255 } } }, { &#34;port&#34;: 1080, &#34;protocol&#34;: &#34;socks&#34;, &#34;sniffing&#34;: { &#34;enabled&#34;: true, &#34;destOverride&#34;: [ &#34;http&#34;, &#34;tls&#34; ] }, &#34;settings&#34;: { &#34;auth&#34;: &#34;noauth&#34; } } ], &#34;outbounds&#34;: [ { &#34;tag&#34;: &#34;proxy&#34;, &#34;protocol&#34;: &#34;vmess&#34;, &#34;settings&#34;: { &#34;vnext&#34;: [ { &#34;address&#34;: &#34;remote ip&#34;, &#34;port&#34;: 10086, &#34;users&#34;: [ { &#34;id&#34;: &#34;***-***-***-***-***&#34;, &#34;alterId&#34;: 0, &#34;security&#34;: &#34;auto&#34; } ] } ] }, &#34;streamSettings&#34;: { &#34;sockopt&#34;: { &#34;mark&#34;: 255 }, &#34;network&#34;: &#34;ws&#34;, &#34;wsSettings&#34;: { &#34;path&#34;: &#34;/&#34;, &#34;headers&#34;: { &#34;Host&#34;: &#34;&#34; } } }, &#34;mux&#34;: { &#34;enabled&#34;: true } }, { &#34;tag&#34;: &#34;direct&#34;, &#34;protocol&#34;: &#34;freedom&#34;, &#34;settings&#34;: { &#34;domainStrategy&#34;: &#34;UseIP&#34; }, &#34;streamSettings&#34;: { &#34;sockopt&#34;: { &#34;mark&#34;: 255 } } }, { &#34;tag&#34;: &#34;block&#34;, &#34;protocol&#34;: &#34;blackhole&#34;, &#34;settings&#34;: { &#34;response&#34;: { &#34;type&#34;: &#34;http&#34; } } }, { &#34;tag&#34;: &#34;dns-out&#34;, &#34;protocol&#34;: &#34;dns&#34;, &#34;streamSettings&#34;: { &#34;sockopt&#34;: { &#34;mark&#34;: 255 } } } ], &#34;dns&#34;: { &#34;servers&#34;: [ { &#34;address&#34;: &#34;223.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2023-05-04 itemprop="datePublished">May 4, 2023</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2023/2023-01-11-mysql-schedule/">mysql-schedule</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				create event clean_xxl_job on schedule every 1 day do truncate xxl_job_log ; 
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2023-01-11 itemprop="datePublished">January 11, 2023</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-12-16-v2er/">v2网友的一首诗</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				@onice
纽约时间比加州时间早三个小时，
但加州时间并没有变慢。
有人 22 岁就毕业了，
但等了五年才找到好的工作！
有人 25 岁就当上 CEO ，
却在 50 岁去世。
也有人迟到 50 岁才当上 CEO ，
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-12-16 itemprop="datePublished">December 16, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-10-26-how-to-create-a-java-archive-file-with-jdk/">how-to-create-a-java-archive-file-with-jdk</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				JAR 文件支持广泛的功能，包括电子签名、版本控制、包封和其他功能。是什么给了一个 JAR 文件这样的多功能性？
答案是 JAR 文件的清单( manifest.)。
清单是一个特殊的文件，可以包含有关打包在 JAR 文件中的文件的信息。通过调整清单中包含的meta/ meta信息，可以启用 JAR 文件以实现各种目的。
以下，演示如何从普通的java文件打包成jar文件：
MultiThread.java:
import java.lang.management.ManagementFactory;import java.lang.management.ThreadInfo;import java.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-10-26 itemprop="datePublished">October 26, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-10-26-isvalid/">有效的括号</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				题目描述： 给定一个只包括'('，')'，'{'，'}'，'['，']'的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。
示例 1：
输入：s = &quot;()&quot;输出：true示例 2：输入：s = &quot;()[]{}&quot;输出：true示例 3：输入：s = &quot;(]&quot;输出：false提示：1 &lt;= s.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-10-26 itemprop="datePublished">October 26, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-09-21-how-to-access-my-server-with-a-pod/">一个线上服务远程访问的方案</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				背景  kubernetes集群在内网中 服务部署在kubernetes集群中 允许暴露一个端口，可以远程访问  目的  访问内网服务的mysql redis mongodb  方案一 部署一套archery，通过端口暴露到公网，实现远程访问
缺点：只能访问特定服务，archery比较厚重
方案二 内网部署一个pod，运行ssh客户端，预装常用工具，mysql-client，redis-cli等
tmp.yaml
apiVersion: v1 kind: Pod metadata: name: my-svc labels: app.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-09-21 itemprop="datePublished">September 21, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-08-16-mvn-generate-project/">mvn-generate-project</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				use mvn cli to generate a project:
mvn archetype:generate -DgroupId=tk.amrom -DartifactId=proto-java -DinteractiveMode=false -DoutputDirectory=./ explain:
 use plugin archetype:generate require args groutId and artifactId and DinteractiveMode  
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-08-16 itemprop="datePublished">August 16, 2022</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/maven/">
               	 #maven</a></span>
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/mvn/">
               	 #mvn</a></span>
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/java/">
               	 #java</a></span>
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/cli/">
               	 #cli</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-07-14-mysql-1k-columns/">mysql生成宽表脚本</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				需求描述 生成一张有1000个字段的表，每个字段的类型随机，用测试使用。
解决方案 shell脚本生成建表sql generate_sql.sh
#!/bin/bash echo &#34;USE amrom;&#34; echo &#34;CREATE TABLE ONE_K_COLS (&#34; for (( i = 0; i &lt; 999; i++ )) { col_type=`echo &#34;tinyint int(11) bigint(20) varchar(50) char(30) date $RANDOM&#34; | awk &#39;{print $($NF%(NF-1)+1)}&#39;` suffix=`cat /proc/sys/kernel/random/uuid | cut -f5 -d&#34;-&#34;` echo &#34;col&#34;_$suffix&#39; &#39;${col_type}&#39;,&#39; } echo &#34;id int auto_increment,&#34; echo &#34;primary key (id)&#34; echo &#34;) engine=innodb;&#34; exit 0  使用方式：.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-07-14 itemprop="datePublished">July 14, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-06-11-multiple-container-in-one-pod/">multiple-container-in-one-pod</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				在kubernetes中，默认场景下，initContainers中的容器是按照顺序启动的，且存在先后依赖关系，即前一个启动完了，才会启动后一个，containers中则是按照顺序启动，但是不存在依赖关系，这就给一些使用场景带来了麻烦。例如，在使用pod作为流水线的时候，containers中的容器顺序需要存在先后依赖关系。以下记录一些实践方案：
方案一 利用原生的postStart机制，该机制保证了后一个容器在前一个容器发出该信号前不会创建。
实例：
apiVersion: v1 kind: Pod metadata: creationTimestamp: null labels: run: my-pipline name: my-pipline spec: volumes: - name: data emptyDir: {} initContainers: - image: &#34;alpine/git&#34; name: prepare env: - name: repo value: &#34;https://github.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-06-11 itemprop="datePublished">June 11, 2022</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/kubernetes/">
               	 #kubernetes</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-06-07-kubernetes-binary-upgrade/">kubernetes二进制部署升级</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				前提 k8s的部署方式基本上有2中，其一是全部利用kubeadm部署，这种方式会以static pod形式部署各个组件，升级的时候按照kubeadm的手册就行，需要先使用kubeadm upgrade plan获得提示，第二种部署方式是组件全部以二进制形式部署，这种部署的升级的时候需要手动操作，以下记录了一次升级操作的过程。
   组件 升级前 升级后     Etcd 3.4.15 3.4.15   kube-apiserver 1.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-06-07 itemprop="datePublished">June 7, 2022</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/kubernetes/">
               	 #kubernetes</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-05-19-upgrade-kernel/">cetos升级内核</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				背景 发现了一个netns的问题，在v站提问了https://v2ex.com/t/853722#reply2，最后决定升级内核.
upgrade-kernel.sh # 载入公钥 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org # 安装ELRepo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm # 载入elrepo-kernel元数据 yum --disablerepo=\* --enablerepo=elrepo-kernel repolist # 查看可用的rpm包 yum --disablerepo=\* --enablerepo=elrepo-kernel list kernel* # 安装长期支持版本的kernel yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-05-19 itemprop="datePublished">May 19, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-05-12-use-deployment-simuator-daemonset/">使用deployment来模拟daemonset</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				一个yaml文件
apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: id: very-important name: deploy-important namespace: project-tiger spec: replicas: 3 selector: matchLabels: id: very-important strategy: {} template: metadata: creationTimestamp: null labels: id: very-important spec: affinity: podAntiAffinity: requiredDuringSchedulingIgnoredDuringExecution: - topologyKey: kubernetes.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-05-12 itemprop="datePublished">May 12, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-04-26-linux-namespace-overview/">linux network namespace 详解</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				网络名称空间 linux 网络空间用于管理容器的网络，编排工具创建容器的时候往往会为容器创建一个独立的namespace，然后将容器的网络与宿主机的网络打通，即可实现容器与外部网络的通信。
linux namespace的操作命令是ip netns
使用实例   创建一个namespace
[root@localhost ~]# ip netns add net1 [root@localhost ~]# ip netns ls net1 net0 [root@localhost ~]# ip netns exec net1 ip addr 1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00   不同namespace通信
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-04-26 itemprop="datePublished">April 26, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-04-22-multus-cni/">k8sd多网卡方案</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				简介 k8s中，默认为每个容器分配一个网卡，（除了lookback回环外），在一些特定场景下，需要指定网卡信息，或者增加网卡，则需要制定多网卡方案。 场景如下： 应用启动时候需要检查mac和ip地址和证书验证，此时如果使用默认的动态网卡方案，则签发的证书无法长期生效。
方案 使用方案 multus-cni 该方案，会在每个节点部署守护进程，根据pod上的注解信息，决定添加自定义网卡。GitHub地址:https://github.com/k8snetworkplumbingwg/multus-cni.git
使用 第一步 部署crd文件，multus-daemonset-thick-plugin.yml
--- apiVersion: apiextensions.k8s.io/v1 kind: CustomResourceDefinition metadata: name: network-attachment-definitions.k8s.cni.cncf.io spec: group: k8s.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-04-22 itemprop="datePublished">April 22, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-04-03-network-policy/">network-policy</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				一个网络隔离策略讲解 apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: my-networkpolicy namespace: mysql spec: podSelector: {} policyTypes: - Ingress ingress: - from: - namespaceSelector: matchLabels: name: internal ports: - protocol: TCP port: 8080 解释 该策略：
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-04-03 itemprop="datePublished">April 3, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-03-31-pod-configmap/">pod挂载configmap</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				nginx.yaml
apiVersion: v1 kind: Pod metadata: creationTimestamp: null labels: run: nginx name: nginx spec: containers: - image: nginx imagePullPolicy: IfNotPresent name: nginx resources: {} env: - name: option # name of the env variable valueFrom: configMapKeyRef: name: options # name of config map key: var5 # name of the entity in config map dnsPolicy: ClusterFirst restartPolicy: Never status: {} options.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-03-31 itemprop="datePublished">March 31, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-03-13-mysql-privileges/">mysql权限高级</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				问题： 如何创建一个新用户，并屏蔽旧库权限？
答案： 问题是对mysql的权限理解有问题。 mysql的权限有2个操作符,grant(授予)和revoke(撤销)。旧库的权限是不能屏蔽的，必须每一个剔除允许的列表。
操作实例
create user 'test'@'%' identified by '123456'; grant all privileges on `test%` to 'test'@'%'; 以上操作会给予test用户，作用域test开头的所有库的所有权限。
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-03-12 itemprop="datePublished">March 12, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-03-10-about-pv-pvc/">关于pv pvc的新认识</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				新认识
 hostpath可以直接使用  apiVersion: v1 kind: Pod metadata: name: pod-hostpath spec: nodeSelector: kubernetes.io/hostname: i-6fns0nua containers: - image: busybox name: app volumeMounts: - mountPath: /logs name: shared-dir args: - /bin/sh - -c - echo hostpath &gt;&gt; /logs/app.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-03-10 itemprop="datePublished">March 10, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-03-03-esxi-cloud-init/">esxi-cloud-init使用</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				esxi是虚拟化的常见方案，其直接部署到物理机上，在之上可以虚拟化出来不同的系统。部署一个虚拟机，我们常见的操作方式是登录esxi的控制台或者vcenter的控制台操作，步骤比较繁琐。
cloud-init是云厂商常用的方案，用于工作在虚拟机初始化的时候。例如，原生部署虚拟机的时候，需要在网页上设置磁盘，用户，网络等等，在cloud-init中，这些不必操作；原生部署虚拟机的时候，无法添加自定义源，cloud-init可以实现。
使用到的工具  govc  govc 是vmware出的cli工具，用于操作vcenter
第一步 配置esxi.env配置 # vCenter host export GOVC_URL=192.168.123.138 # vCenter credentials export GOVC_USERNAME=administrator@vsphere.local export GOVC_PASSWORD=rpK0qGVhd#YIxP4~S26+ # disable cert validation export GOVC_INSECURE=1 export GOVC_DATASTORE=bigdata export GOVC_NETWORK=&#34;&#34; export GOVC_RESOURCE_POOL=&#39;default-cluster/Resources&#39; export GOVC_DATACENTER=default-dc jinbao666lin@jinbao666deMacBook-Pro govc-practice % govc about FullName: VMware vCenter Server 6.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-03-03 itemprop="datePublished">March 3, 2022</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/">
               	 #虚拟化</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-02-28-etcd-clean/">etcd强制删除k8s数据</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				k8s由于各种原因，导致pod等数据一直处于terminting状态中，可以考虑到etcd中强制删除
#检索pod数据 etcdctl --endpoints=https://127.0.0.1:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/ca.crt --key=/etc/kubernetes/pki/etcd/ca.key get /registry/pod --prefix --keys-only #根据关键字清楚 export ssss=calico etcdctl --endpoints=https://127.0.0.1:2379 --cacert=/etc/kubernetes/pki/etcd/ca.crt --cert=/etc/kubernetes/pki/etcd/ca.crt --key=/etc/kubernetes/pki/etcd/ca.key get /registry --prefix --keys-only | grep ${ssss} | xargs -I{} etcdctl --endpoints=https://127.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-02-28 itemprop="datePublished">February 28, 2022</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/etcd/">
               	 #etcd</a></span>
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/kubernetes/">
               	 #kubernetes</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2022/2022-02-16-node-note/">node节点安装笔记</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				node节点安装笔记
yum install containerd.io cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # Setup required sysctl params, these persist across reboots.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2022-02-16 itemprop="datePublished">February 16, 2022</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-11-29-iptables/">iptables操作实例</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				4个表:filter,mangle,nat,raw
3个链:PREROUTING,PREROUTING,PREROUTING
iptabls基本操作示例 查看规则 查看规则集
iptables --list -n 加一个-n以数字形式显示IP和端口，而不是默认的服务名称
修改规则 配置默认规则，不允许数据进入
iptables -P INPUT DROP 允许转发
iptables -P FORWARD ACCEPT 不允许数据流出
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-11-29 itemprop="datePublished">November 29, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-10-28-kubeconfig/">kubeconfig签发</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				签发一个kubeconfig文件的详细流程 大致步骤：
 cfssl证书 定义集群 定义用户 定义上下文 绑定角色  cfssl证书 ca-config.json cfssl的配置文件
{ &#34;signing&#34;: { &#34;default&#34;: { &#34;expiry&#34;: &#34;87600h&#34; }, &#34;profiles&#34;: { &#34;kubernetes&#34;: { &#34;usages&#34;: [ &#34;signing&#34;, &#34;key encipherment&#34;, &#34;server auth&#34;, &#34;client auth&#34; ], &#34;expiry&#34;: &#34;876000h&#34; } } } } user-csr.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-10-28 itemprop="datePublished">October 28, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-08-21-cloudflare-worker/">cloudflare worker使用</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				部署ariang到cloudflare workers
mkdir -p ariang/public cd ariang/public wget https://github.com/mayswind/AriaNg/releases/download/1.1.7/AriaNg-1.1.7.zip unzip AriaNg-1.1.7.zip rm -f AriaNg-1.1.7.zip cd .. wrangler init --site ariang wrangler config wrangler publish wrangler.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-08-21 itemprop="datePublished">August 21, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-08-20-golang-build/">golang交叉编译</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				Golang 支持在一个平台下生成另一个平台可执行程序的交叉编译功能。
1、Mac下编译Linux, Windows平台的64位可执行程序 CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build test.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build test.go 2、Linux下编译Mac, Windows平台的64位可执行程序 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build test.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-08-20 itemprop="datePublished">August 20, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-08-18-oci/">关于镜像oci规范</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				早就知道镜像存在OCI规范，就是在镜像的元数据中加入一些表明镜像信息的标签，不知道如何，一次偶然就会在github的流水线中看到了，记录下来：
{ &#34;target&#34;: { &#34;docker-metadata-action&#34;: { &#34;tags&#34;: [ &#34;ghcr.io/linjinbao666/conda-base:main&#34; ], &#34;labels&#34;: { &#34;org.opencontainers.image.title&#34;: &#34;conda-base&#34;, &#34;org.opencontainers.image.description&#34;: &#34;conda-base&#34;, &#34;org.opencontainers.image.url&#34;: &#34;https://github.com/linjinbao666/conda-base&#34;, &#34;org.opencontainers.image.source&#34;: &#34;https://github.com/linjinbao666/conda-base&#34;, &#34;org.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-08-18 itemprop="datePublished">August 18, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-08-13-gitlab-ci-sample/">一个gitlab ci文件</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				一个golang项目典型的gitlab ci文件
image: golang:latest before_script: - export GOPROXY=https://goproxy.io,direct stages: - build - release - note build: stage: build script: - go build -o dt-release artifacts: paths: - .
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-08-12 itemprop="datePublished">August 12, 2021</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/gitlab/">
               	 #gitlab</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-08-10-shell/">一个shell程序</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				一个简单的shell程序： app.sh
#!/bin/bash  action=$1 version=$2 app_name=shuqi-public-${version} load() { file_name=shuqi-public-${version}.tar docker load -i data/${file_name} } clean() { old_container=`docker container ls | grep ${app_name}` if [ -n &#34;${old_container}&#34; ]; then echo &#34;程序运行中，请先停止程序&#34; exit; fi docker rm ${app_name} } start() { old_container=`docker container ls | grep ${app_name}` if [ -n &#34;${old_container}&#34; ]; then echo &#34;程序已经在运行，请先停止&#34; exit; fi ip=`ip a | grep -v docker0 |grep inet|grep -v 127.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-08-10 itemprop="datePublished">August 10, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-08-06-hcloud-sdk-trip/">华为云sdk踩坑</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				简介 工作中用到了华为云，想使用华为云的sdk实现批量启动流水线，分发代码等任务，简单试用了下，发现问题太多。
问题   api区域开放问题
华为云的api调用大致有3种方式，apiexplorer在线调用、hcloud命令行调用，以及通过sdk调用。而同时华为云有区域的区分，比如华东-上海二，华东-北京一这种。api在有些区域开放了调用，但是在另一区域则不开放。举例说明：CloudPipeline（流水线）api开放区域为：上海二、上海一、北京一、北京四、广州，一共5个区域，但是CloudBuild（编译构建）api开放区域则缺少了上海一。要知道CloudBuild会依赖CloudPipeline使用，前一步的api开放了，后一步却不开放，导致根本无法使用。
  文档没有示例或者示例是错误的
CloudPipeline的一个接口，ListPipelineSimpleInfo，官方给出的请求示例为：
&quot;POST https://{endpoint}/v3/pipelines/list&quot; 文档中根本没给出这个endpoint是什么样式的，后续经过尝试发现hcloud也会配置这个endpoint，其为cn-east-3，但是sdk调用时，其格式变成了：cloudpipeline-ext.cn-east-3.myhuaweicloud.com。样例的缺失，导致了调试成本巨大。
  api混乱，缺少
举例来说，CloudPipeline流水线api，没有查看单条流水线详情的api等等
  收获 经过不断的踩坑，实验出来了几个api的调用示例，贴出来以后备用。
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-08-06 itemprop="datePublished">August 6, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-08-05-bubble-ports/">冒号端口</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				Linux程序监听网卡端口的时候会有各种缩写，其中有一种叫做冒号端口的写法。
现象 首先，我们看一段netstat的输出：
root@VM-0-4-debian:~# netstat -tunlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-08-05 itemprop="datePublished">August 5, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-07-15-one-complex-sql/">一条复杂的sql</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				USE zentao; SELECT zt_task.id AS &#39;编号&#39;, zt_projectproduct.product AS &#39;所属产品&#39;, zt_product.`name` AS &#39;产品名称&#39;, zt_project.NAME AS &#39;所属项目&#39;, zt_story.title AS &#39;相关需求&#39;, zt_task.NAME AS &#39;任务名称&#39;, CASE zt_task.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-07-15 itemprop="datePublished">July 15, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-06-30-kubernetes-contexts/">kubernetes多用户切换</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				k8s中多用户使用，主要命令在kubectl config命令下，执行kubectl config可以看到提示：
[root@node1 ansible]# kubectl config Modify kubeconfig files using subcommands like &quot;kubectl config set current-context my-context&quot; The loading order follows these rules: 1.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-06-30 itemprop="datePublished">June 30, 2021</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/kubernetes/">
               	 #kubernetes</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-06-15-gitops/">GitOps入门</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				GitOps概念 GitOps是一种实现持续交付的模型，利用Git开发工具对云原生应用程序进行操作和管理。当将应用程序部署到Kubernetes时，Git应该是唯一的事实来源。当开发人员更改应用程序时，Git将自动把它们push到Kubernetes进行部署。而且，如果Kubernetes内的运行状态发生变化但与Git内的状态不一致，则它们会从Git内恢复到已知状态。
参考：https://about.gitlab.com/topics/gitops/
GitOps与CI/CD GitOps和CI/CD是十分重要的工作伙伴。CI/CD可以让开发人员持续迭代、开发和部署应用程序。而迭代通常通过一个Git配置仓库进行（尽管也会有其他配置仓库）。在部署/交付阶段，构建的基于容器的应用程序被“push”到Kubernetes进行部署。GitOps会通过Kubernetes使用“pull”的方法来增强CI/CD模型，从而将运维层面带入部署/交付中。
但是，如果有人更改了Kubernetes集群中运行的某些内容，会发生什么？我们将使用Git作为声明性部署工具的主要事实来源，并利用其他工具在出现差异时向我们发出警报。此外，通过利用可以识别运行状态和声明状态之间差异的工具，Kubernetes可以修复为已知/声明的运行状态。
注意：持续集成和持续开发是互补但独立的过程。在理想状态下，GitOps会将批处理规模拆分为单件流程，每次只处理一个单元。但是，由于CI和CD流程发生在不同的组中，因此组织之间的流程可能会有所不同。
GitOps和应用程序生命周期 让我们从应用程序生命周期的视角来看一下GitOps的作用。在典型的生命周期中，应用程序会经历多个状态，包括：
  代码
  构建
  创建镜像
  测试
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-06-15 itemprop="datePublished">June 15, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-06-01-golang-fallthrough/">golang fallthrough用法</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				fallthrough：Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。
示例：切割字符串输出格式
func main() { const text = `Galaksinin Batı Sarmal Kolu&#39;nun bir ucunda, haritası bile çıkarılmamış ücra bir köşede, gözlerden uzak, küçük ve sarı bir güneş vardır.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-06-01 itemprop="datePublished">June 1, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-05-10-log-metrics-in-cloud-native-environment/">云原生时代日志采集方案浅谈</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				引言 本文基于kubernetes容器平台，分析容器日志采集的前因后果，通过比对EFK和Loki的方案，讨论云原生时代容器日志收集与分析的重点所在。
当服务从裸机部署进入容器时代，容器的强大隔离性与封装性，使得服务的日志变得不稳定。原本裸机运行的程序使用容器运行时，极易由于自动重启，或者自动重建等特性而丢失日志，即便采用了持久化挂载，依然无法根本问题：日志易丢失。对于一个大规模集群而言，完善的日志收集变得越来越重要。
需要采集日志的场景 可以说，基本上所有的程序的日志都应该采集，即使是那些一次性的job等。日志的采集不仅仅是提供给排查bug人员，而且应当作为系统审计的角色存在。收集整个容器平台的所有日志看起来是件多余的事情，毕竟大多数的日志并无用处，但是对于严谨的业务而言，日志是发现问题的最佳途径。
方案一 EFK 就kubernetes平台而言，日志的采集方案比较流行的有EFK，其中E是指elasticsearch，K是指kibana，但是F，有两种说法，一种是指fluentd，另一种是指filebeat；一般分析认为，fluentd相比较于filebeat属于重量级程序。本文任务此处为fluentd。EFK方案的架构很明确，fluentd以DaemonSet形式运行在集群所有节点上，在即指定路径的宿主机日志，例如：/var/log/pods；fluentd采集到日志后，传输到elasticsearch存储，elastic作为一个强大的全文检索引擎，具备良好的并发存储于查询的能力；kibana作为日志的展示工具。
EFK方案实现起来比较成熟，目前多数的方案都是用的是这种，包括k8s官方提供的插件中就有此种方案。但是该方案存在明显的缺陷：
 Elastic Search 的编写语言是Java，其运行时非常占用内存，有时需要把elastic移除到集群外部部署。 Elastic Search存储的内容虽然比较多，但是大多数并不需要采集。  方案二 Loki Loki是近期比较流行的k8s日志采集方案。博主认为，说Loki是日志采集方案其实是不准确的。先来看Loki采集的原理：
Loki也采用了代理程序与服务端结合的设计：
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-05-10 itemprop="datePublished">May 10, 2021</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/kubernetes/">
               	 #kubernetes</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-05-05-what-is-devops/">什么是DevOps</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				什么是DevOps：
维基百科的解释：https://en.wikipedia.org/wiki/DevOps
 DevOps is a set of practices that combines software development (Dev) and IT operations (Ops). It aims to shorten the systems development life cycle and provide continuous delivery with high software quality.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-05-05 itemprop="datePublished">May 5, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-03-25-k8s-glusterfs/">k8s整合glusterfs做后端存储</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				安装glusterfs和heketi
#所有存储服务器下载安装glusterfs yum install centos-release-gluster -y yum install glusterfs-server -y #启动 systemctl start glusterd #安装heketi yum install -y heketi heketi-client   部署gluster集群
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-03-25 itemprop="datePublished">March 25, 2021</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/kubernetes/">
               	 #kubernetes</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-03-22-tar-system/">tar打包现有的系统</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				选择一个系统，在根目录下将已有系统打包成tar文件：
tar -cvpf /tmp/system.tar --directory=/ --exclude=proc --exclude=sys --exclude=dev --exclude=run --exclude=boot --exclude=/opt/software . 导入方式一：
cat system.tar | docker import - redhat:6.5 导入方式二：
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-03-22 itemprop="datePublished">March 22, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-03-19-git-ignore-one-file/">git单独忽略一个文件的历史提交</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				使用场景：
将一个重要文件，勿加入git的版本管理中了，后续又更新了好多版本，此时想要去除该文件的所有历史提交。
 方案一：删除所有git记录 方案二：单独删除该文件的历史记录  方案二操作如下：
git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch visitor-consumer/src/main/java/com/fline/util/SMSUtil.java' --prune-empty --tag-name-filter cat -- --all git push origin --force --all git push origin --force --tags git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin git reflog expire --expire=now --all git gc --prune=now 
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-03-19 itemprop="datePublished">March 19, 2021</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/git/">
               	 #git</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-03-17-scratch/">空镜像</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				如何将当前宿主机制作成镜像？
答案：借助scratch 镜像
scratch 是一个空镜像，只能用于构建其他镜像，比如你要运行一个包含所有依赖的二进制文件，如Golang 程序，可以直接使用 scratch 作为基础镜像。例如busybox的Dockerfile写法：
FROM scratch ADD busybox.tar.xz / CMD [&quot;sh&quot;] 将当前机器制作成OS镜像，使用docker build即可。
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-03-17 itemprop="datePublished">March 17, 2021</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/docker/">
               	 #docker</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-02-01-cidr/">子网掩码表示</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				示例：
192.168.2.0/24 表示 固定前24位，后8位可以任意变动，所以表示的ip段为192.168.2.0-192.168.2.255。
192.168.2.0/24 表示 固定前26位，后6位可以任意变动，所以表示的ip共有2^6-2个。
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-02-01 itemprop="datePublished">February 1, 2021</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2021/2021-01-28-k8s-in-action-note/">k8s in action 阅读笔记</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				如何保证多次请求命中同一个pod？  If you execute the same command a few more times, you should hit a different pod with every invocation, because the service proxy normally forwards each connection to a randomly selected backing pod, even if the connections are coming from the same client.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2021-01-28 itemprop="datePublished">January 28, 2021</time>
                </span>
                in
                
        	</div>
				
				<div class="post-tags">
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/kubernetes/">
               	 #kubernetes</a></span>
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/k8s/">
               	 #k8s</a></span>
        		
        			<span class="tag"><a href="https://amrom66.github.io/tags/cloud-native/">
               	 #cloud native</a></span>
        		
				</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2020/2020-12-30-jdk1.15-build/">jdk1.15编译</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				jdk1.15编译 github下载项目 https://github.com/openjdk/jdk
安装依赖 yum -y install build-essential gawk m4 libasound2-print-dev binutils libmotif3 libmotif-dev ant yum install libX* yum install fontconfig-devel yum install autoconf yum install -y centos-release-scl yum install -y devtoolset-7 yum install libXtst-devel libXt-devel libXrender-devel libXrandr-devel libXi-devel -y yum install cups-devel yum install fontconfig-devel yum install alsa-lib-devel -y 编译 make images
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2020-12-30 itemprop="datePublished">December 30, 2020</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2020/2020-11-16-containerd-image-import/">containerd手动导入镜像</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				众所周知，k8s.gcr.io 长期被墙，导致 k8s 的基础容器 pause 经常无法获取。k8s docker 可使用代理服拉取，再利用 docker tag 解决问题
docker pull mirrorgooglecontainers/pause:3.1 docker tag mirrorgooglecontainers/pause:3.1 k8s.gcr.io/pause:3.1 我在 k8s 集群中尝试使用 containerd 作为 CRI，发现镜像下载和导入与 docker 存在一些区别，大致如下：
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2020-11-16 itemprop="datePublished">November 16, 2020</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2020/2020-11-10-nginx-reffer/">nginx拦截空reffer</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				背景解释 web系统出现垂直越权的现象，具体表现为，低权限账户登录后，直接请求高权限的接口可以获取数据，原因在于后台并没有实现对接口的权限校验，只是在菜单上简单隐藏。
解决方案 方案一：引入完善的权限框架，例如shiro
方案二：nginx控制reffer，禁止直接访问
配置实例：
location /login.html { root D:\code2\fdmp-pages; autoindex on; index index.html; } location / { valid_referers server_names ~.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2020-11-10 itemprop="datePublished">November 10, 2020</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2020/about/">关于</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				纽约时间比加州时间早三个小时， 但加州时间并没有变慢。 有人 22 岁就毕业了， 但等了五年才找到好的工作！ 有人 25 岁就当上 CEO ， 却在 50 岁去世。 也有人迟到 50 岁才当上 CEO ， 然后活到 90 岁。 有人依然单身， 同时也有人已婚。 奥巴马 55 岁就退休， 川普 70 岁才开始当总统。 世上每个人本来就有自己的发展时区。 身边有些人看似走在你前面， 也有人看似走在你后面。 但其实每个人在自己的时区有自己的步程。 不用嫉妒或嘲笑他们。 他们都在自己的时区里，你也是！ 生命就是等待正确的行动时机。 所以，放轻松。 你没有落后。 你没有领先。 在命运为你安排的属于自己的时区里，一切都准时。
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2020-11-03 itemprop="datePublished">November 3, 2020</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2020/2020-10-16-k8s-rbac/">k8s的rbac权限控制</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				简介 rbac权限控制是role based access control的简写，中文名基于角色的权限控制。
RBAC API 对象 Kubernetes有一个很基本的特性就是它的所有资源对象都是模型化的 API 对象，允许执行 CRUD(Create、Read、Update、Delete)操作(也就是我们常说的增、删、改、查操作)，比如下面的这下资源：
 Pods ConfigMaps Deployments Nodes Secrets Namespaces  上面这些资源对象的可能存在的操作有：
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2020-10-16 itemprop="datePublished">October 16, 2020</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2020/2020-10-14-linux-cgroups/">linux cgroups简单使用</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				简介 cgroups 是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对 cpu，内存等资源实现精细化的控制，目前越来越火的轻量级容器 Docker 就使用了 cgroups 提供的资源限制能力来完成cpu，内存等部分的资源控制。另外，开发者也可以使用 cgroups 提供的精细化控制能力，限制某一个或者某一组进程的资源使用。比如在一个既部署了前端 web 服务，也部署了后端计算模块的八核服务器上，可以使用 cgroups 限制 web server 仅可以使用其中的六个核，把剩下的两个核留给后端计算模块。
简单理解：cgroups可以实现cpu和内存的机器资源的精细化控制，比如限制使用10%的cpu资源，使用100M内存等功能。Docker容器运行时通过参数指定内存和cpu占用功能就是基于这个实现的。
主要作用 实现 cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups 提供了四大功能：
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2020-10-14 itemprop="datePublished">October 14, 2020</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
		<article class="post" itemscope itemscope="" itemtype="http://schema.org/Article">

			<header class="post-header">
				<h1 class="post-title" itemprop="name headline"><a href="https://amrom66.github.io/2020/2020-09-05-websocket-useage-in-java-practice/">spring 使用websocket主动推送日志到页面展示</a></h1>
			</header>
			<div class="post-content">
				 
				   
       			 
				简介 Java程序运行的时候会产生大量的日志，有的是自己主动打印的，有些的第三方包中打印的日志，一些场景下需要将程序执行过程中的日志主动推送出去，例如使用docker-java制作镜像的时候，我需要将制作过程大日志输出到页面，用来判断制作过程。
相关流程  logback日志切割 阻塞队列/环形队列处理并发读写 websocket推送  方案一实现 很明显，日志需要通过log4j等日志框架收集。我们需要自定义一个过滤器，处理需要的日志信息，在过滤器中将日志存到阻塞队列或者环形队列。配置如下：
logback.xml
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt;&lt;configuration scan=&#34;true&#34; scanPeriod=&#34;3 seconds&#34;&gt;&lt;!--设置日志输出为控制台--&gt;&lt;include resource=&#34;org/springframework/boot/logging/logback/defaults.
			</div>
			<div class="post-footer">
				<div class="post-meta">
                <span class="post-time">
                <time datetime=2020-09-05 itemprop="datePublished">September 5, 2020</time>
                </span>
                in
                
        	</div>
				
			</div>
		</article>
	
	<div>
		<h1 class="post-title" itemprop="name headline"><a href="/posts/">所有文章</a></h1>
	</div>
</div>

  

          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2024</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://amrom66.github.io">linjinbao66</a>  </span> 
         

         
		 
    </div>
</footer>











    
    <script src="/js/vendor_main.min.js" async=""></script>



     </div>
  </body>
</html>
