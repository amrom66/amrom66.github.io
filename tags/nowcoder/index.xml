<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nowcoder on 打工人日记</title>
    <link>https://linjinbao.github.io/tags/nowcoder/</link>
    <description>Recent content in nowcoder on 打工人日记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://linjinbao.github.io/tags/nowcoder/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>牛客网题目-树的子结构</title>
      <link>https://linjinbao.github.io/2019/20190925-shu-de-zi-jie-gou/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/20190925-shu-de-zi-jie-gou/</guid>
      <description>2019-09-25-树的子结构 题目名称：树的子结构 题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
分析： 第一想法是递归，只要是树，我就上递归。分析情况有以下3种：
 当前root1节点=当前root2节点 当前root1节点！=当前root2节点，但是root1.left和root2节点相等 当前root1节点！=当前root2节点，但是root1.right和root2节点相等  所以需要一个辅助函数helper
public static boolean hasSubtree(TreeNode root1, TreeNode root2) { if (root1==null || root2==null) return false; //三种情况  return helper(root1,root2) || hasSubtree(root1.left, root2) || hasSubtree(root1.right,root2); } //递归检查  public static boolean helper(TreeNode root1, TreeNode root2){ if (root2==null) return true; if (root1==null) return false; if (root1.val==root2.val)return helper(root1.left,root2.left)&amp;amp;&amp;amp;helper(root1.right,root2.right); return false; } 总结 遇到二叉树，递归总没错</description>
    </item>
    
    <item>
      <title>牛客网题目-树的子结构</title>
      <link>https://linjinbao.github.io/2019/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>题目名称：树的子结构 题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
分析： 第一想法是递归，只要是树，我就上递归。分析情况有以下3种：
  当前root1节点=当前root2节点
  当前root1节点！=当前root2节点，但是root1.left和root2节点相等
  当前root1节点！=当前root2节点，但是root1.right和root2节点相等
  所以需要一个辅助函数helper
public static boolean hasSubtree(TreeNode root1, TreeNode root2) {if (root1==null || root2==null) return false;//三种情况 return helper(root1,root2) || hasSubtree(root1.left, root2) || hasSubtree(root1.right,root2);}//递归检查 public static boolean helper(TreeNode root1, TreeNode root2){if (root2==null) return true;if (root1==null) return false;if (root1.val==root2.val)return helper(root1.left,root2.left)&amp;amp;&amp;amp;helper(root1.right,root2.right);return false;}总结 遇到二叉树，递归总没错</description>
    </item>
    
  </channel>
</rss>