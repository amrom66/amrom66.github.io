<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发 on 打工人日记</title>
    <link>https://linjinbao.github.io/tags/%E5%BC%80%E5%8F%91/</link>
    <description>Recent content in 开发 on 打工人日记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 14 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://linjinbao.github.io/tags/%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>排序算法总结</title>
      <link>https://linjinbao.github.io/2019/2019-09-14-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 14 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-14-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>排序总结 冒泡排序 原理：每次比较两个相邻的元素，将较大元素交换至右端 特点：每次循环结束，会出现一个排序好的元素，右侧 理解：大的数右移，重复此过程 代码：
public static void bubbleSort(int[] nums){ for (int i=0; i&amp;lt;nums.length-1; i++){ //第i次循环找出第i小的元素0&amp;lt;=i&amp;lt;=length-1  for (int j=0; j&amp;lt;nums.length-1-i; j++){ if (nums[j+1]&amp;lt;nums[j]){ int tmp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = tmp; } for (int num : nums) System.out.print(num+&amp;#34;\t&amp;#34;); System.out.println(); } } } 优化：使用flag标记是否已经有序
选择排序 原理：每次循环找出最小的元素于左侧，每次循环都从剩余未排序系列找出最小的元素 代码：
/** * 选择排序 * @param nums */ public static void selectSort(int[] nums){ int len = nums.length; if (len==0 || len==1) return; for (int i=0; i&amp;lt;len; i++){ for (int j=i+1; j&amp;lt;len; j++){ if (nums[j] &amp;lt; nums[i]){ int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } } } 插入排序 原理：递归思想，假设第一个有序，则新插入一个，将其排序，循环递归 代</description>
    </item>
    
    <item>
      <title>排序算法总结</title>
      <link>https://linjinbao.github.io/2019/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 14 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</guid>
      <description>排序总结 冒泡排序 原理：每次比较两个相邻的元素，将较大元素交换至右端 特点：每次循环结束，会出现一个排序好的元素，右侧 理解：大的数右移，重复此过程 代码：
public static void bubbleSort(int[] nums){for (int i=0; i&amp;lt;nums.length-1; i++){ //第i次循环找出第i小的元素0&amp;lt;=i&amp;lt;=length-1 for (int j=0; j&amp;lt;nums.length-1-i; j++){if (nums[j+1]&amp;lt;nums[j]){int tmp = nums[j];nums[j] = nums[j+1];nums[j+1] = tmp;}for (int num : nums) System.out.print(num+&amp;#34;\t&amp;#34;);System.out.println();}}}优化：使用flag标记是否已经有序
选择排序 原理：每次循环找出最小的元素于左侧，每次循环都从剩余未排序系列找出最小的元素 代码：
/*** 选择排序* @param nums*/public static void selectSort(int[] nums){int len = nums.length;if (len==0 || len==1) return;for (int i=0; i&amp;lt;len; i++){for (int j=i+1; j&amp;lt;len; j++){if (nums[j] &amp;lt; nums[i]){int tmp = nums[i];nums[i] = nums[j];nums[j] = tmp;}}}}插入排序 原理：递归思想，假设第一个有序，则新插入一个，将其排序，循环递归 代</description>
    </item>
    
  </channel>
</rss>