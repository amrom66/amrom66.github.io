<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程 on 打工人日记</title>
    <link>https://linjinbao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
    <description>Recent content in 多线程 on 打工人日记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 03 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://linjinbao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java多线程处理数据表格</title>
      <link>https://linjinbao.github.io/2019/20191203java-duo-xian-cheng-chu-li-shu-ju-biao-ge/</link>
      <pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/20191203java-duo-xian-cheng-chu-li-shu-ju-biao-ge/</guid>
      <description>java多线程处理数据表格 问题描述： 现在需要处理一个excel表格，数据量几百条，我使用多线程处理
思路描述： 使用import java.util.concurrent.ExecutorService;和import java.util.concurrent.Executors;类实现
核心代码：
ExecutorService e = Executors.newFixedThreadPool(10); e.submit(new Runnable() { @Override public void run() { Long id = Thread.currentThread().getId(); logger.info(&amp;#34;当前线程：&amp;#34; + id); try { gr(inpath, outpath, prefix1); } catch (Exception e) { logger.error(&amp;#34;----------转化错误，请参照说明文档-------&amp;#34;); e.printStackTrace(); } } }); e.submit(new Runnable() { @Override public void run() { Long id = Thread.currentThread().getId(); logger.info(&amp;#34;当前线程：&amp;#34; + id); try { fr(inpath, outpath, prefix2, prefix3); } catch (IOException e) { logger.error(&amp;#34;----------转化错误，请参照说明文档-------&amp;#34;); e.printStackTrace(); } } }); e.</description>
    </item>
    
    <item>
      <title>java多线程处理数据表格</title>
      <link>https://linjinbao.github.io/2019/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC/</link>
      <pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%A0%BC/</guid>
      <description>java多线程处理数据表格 问题描述： 现在需要处理一个excel表格，数据量几百条，我使用多线程处理
思路描述： 使用import java.util.concurrent.ExecutorService;和import java.util.concurrent.Executors;类实现
核心代码：
ExecutorService e = Executors.newFixedThreadPool(10);e.submit(new Runnable() {@Overridepublic void run() {Long id = Thread.currentThread().getId();logger.info(&amp;#34;当前线程：&amp;#34; + id);try {gr(inpath, outpath, prefix1);} catch (Exception e) {logger.error(&amp;#34;----------转化错误，请参照说明文档-------&amp;#34;);e.printStackTrace();}}});e.submit(new Runnable() {@Overridepublic void run() {Long id = Thread.currentThread().getId();logger.info(&amp;#34;当前线程：&amp;#34; + id);try {fr(inpath, outpath, prefix2, prefix3);} catch (IOException e) {logger.error(&amp;#34;----------转化错误，请参照说明文档-------&amp;#34;);e.printStackTrace();}}});e.</description>
    </item>
    
    <item>
      <title>java创建线程的7种方式</title>
      <link>https://linjinbao.github.io/2019/20191009java-chuang-jian-xian-cheng-de-8-zhong-fang-shi/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/20191009java-chuang-jian-xian-cheng-de-8-zhong-fang-shi/</guid>
      <description>java创建线程的7种方式  继承Thread类并重写run()方法  public class MyThread extends Thread { @Override public void run() { System.out.println(this.getId()+this.getName()+ &amp;#34; is running&amp;#34;); } public static void main(String[] arg){ new MyThread().start(); new MyThread().start(); new MyThread().start(); new MyThread().start(); } } $ &amp;#34;C:\Program Files\Java\jdk1.8.0_171\bin\java.exe&amp;#34; 12Thread-0 is running 15Thread-3 is running 13Thread-1 is running 14Thread-2 is running Process finished with exit code 0  实现Runnable接口  public class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+&amp;#34; is running&amp;#34;); } public static void main(String[] args){ new Thread(new MyThread()).</description>
    </item>
    
    <item>
      <title>java创建线程的7种方式</title>
      <link>https://linjinbao.github.io/2019/java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%848%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>java创建线程的7种方式  继承Thread类并重写run()方法  public class MyThread extends Thread {@Overridepublic void run() {System.out.println(this.getId()+this.getName()+ &amp;#34; is running&amp;#34;);}public static void main(String[] arg){new MyThread().start();new MyThread().start();new MyThread().start();new MyThread().start();}}$ &amp;quot;C:\Program Files\Java\jdk1.8.0_171\bin\java.exe&amp;quot;12Thread-0 is running15Thread-3 is running13Thread-1 is running14Thread-2 is runningProcess finished with exit code 0实现Runnable接口  public class MyThread implements Runnable{@Overridepublic void run() {System.out.println(Thread.currentThread().getName()+&amp;#34; is running&amp;#34;);}public static void main(String[] args){new Thread(new MyThread()).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://linjinbao.github.io/2019/20191003-duo-xian-cheng-ji-suan-yuan-zhou-shuai/</link>
      <pubDate>Thu, 03 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/20191003-duo-xian-cheng-ji-suan-yuan-zhou-shuai/</guid>
      <description>多线程计算圆周率 使用公式1-1/3+1/5&amp;hellip;&amp;hellip;
代码示例 package learn; import java.math.BigDecimal; import java.util.ArrayList; import java.util.concurrent.*; /** * 多线程计算圆周率 */ public class Pie { public static double sum = 0.0; public static void main(String[] args) throws ExecutionException, InterruptedException { int tNum = 64; ExecutorService pool = Executors.newFixedThreadPool(tNum); ArrayList&amp;lt;Future&amp;lt;BigDecimal&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); long tmp = 1000000000; long time0 = System.currentTimeMillis(); System.out.println(&amp;#34;开始计算时间：&amp;#34;+time0); for (int i=0; i&amp;lt; tNum; i++){ long start = 1+tmp*i; long end = start+tmp-1; Callable&amp;lt;BigDecimal&amp;gt; caller = new Pie().</description>
    </item>
    
    <item>
      <title></title>
      <link>https://linjinbao.github.io/2019/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/</link>
      <pubDate>Thu, 03 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/</guid>
      <description>多线程计算圆周率 使用公式1-1/3+1/5&amp;hellip;&amp;hellip;
代码示例 package learn;import java.math.BigDecimal;import java.util.ArrayList;import java.util.concurrent.*;/*** 多线程计算圆周率*/public class Pie {public static double sum = 0.0;public static void main(String[] args) throws ExecutionException, InterruptedException {int tNum = 64;ExecutorService pool = Executors.newFixedThreadPool(tNum);ArrayList&amp;lt;Future&amp;lt;BigDecimal&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();long tmp = 1000000000;long time0 = System.currentTimeMillis();System.out.println(&amp;quot;开始计算时间：&amp;quot;+time0);for (int i=0; i&amp;lt; tNum; i++){long start = 1+tmp*i;long end = start+tmp-1;Callable&amp;lt;BigDecimal&amp;gt; caller = new Pie().</description>
    </item>
    
  </channel>
</rss>