<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 打工人日记</title>
    <link>https://linjinbao.github.io/posts/</link>
    <description>Recent content in Posts on 打工人日记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Mar 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://linjinbao.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>空镜像</title>
      <link>https://linjinbao.github.io/2021/2021-03-17-%E7%A9%BA%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2021/2021-03-17-%E7%A9%BA%E9%95%9C%E5%83%8F/</guid>
      <description>如何将当前宿主机制作成镜像？
答案：借助scratch 镜像
scratch 是一个空镜像，只能用于构建其他镜像，比如你要运行一个包含所有依赖的二进制文件，如Golang 程序，可以直接使用 scratch 作为基础镜像。例如busybox的Dockerfile写法：
FROM scratch ADD busybox.tar.xz / CMD [&amp;quot;sh&amp;quot;] 将当前机器制作成OS镜像，使用docker build即可。</description>
    </item>
    
    <item>
      <title>日常流水账</title>
      <link>https://linjinbao.github.io/2021/2021-03-14-%E6%B5%81%E6%B0%B4%E8%B4%A6/</link>
      <pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2021/2021-03-14-%E6%B5%81%E6%B0%B4%E8%B4%A6/</guid>
      <description>今日花钱：
 午饭18 晚饭14  </description>
    </item>
    
    <item>
      <title>租到房子</title>
      <link>https://linjinbao.github.io/2021/2021-03-13-%E7%A7%9F%E5%88%B0%E6%88%BF%E5%AD%90/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2021/2021-03-13-%E7%A7%9F%E5%88%B0%E6%88%BF%E5%AD%90/</guid>
      <description>  早上在公司门口见到一块钱硬币
  上午租到房子，在昌源清苑，租金1400每个月，押一付一，合同半年，房东顾国强
  下午采购生活用品，花销68.4
  开销：
 早上地铁3.6元 中午吃饭20.8元 房租2800 采购生活用品68.4  </description>
    </item>
    
    <item>
      <title>面试题</title>
      <link>https://linjinbao.github.io/2021/2021-02-23-%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2021/2021-02-23-%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>git合并指定的一次commit  答案：
git cherry-pick commitid git rebase --onto branch commitid git撤销已经推送的提交  答案：
git reset --soft id Java线程间通信  答案：利用线程同步来实现通信，通过while轮询方式，wait/notify机制
ArrayList 与 LinkedList 区别  答案：ArrayList插入和删除等操作比LinkedList慢
HashMap 和 HashTable 的区别  答案：HashTable比HashMap多synchronized关键字，ConcurrentHashMap是HashTable 的替代
java线程池了解吗  答案：Executor 框架，ThreadPoolExecutor的参数作用
public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量 int maximumPoolSize,//线程池的最大线程数 long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间 TimeUnit unit,//时间单位 BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,//任务队列，用来储存等待执行任务的队列 ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可 RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 ) --- redis的两种持久化  答案：RDB和AOF
redis比较Memcached  答案：Redis 支持更丰富的数据类型，Redis 支持数据的持久化，Redis 有灾难恢复机制
Spring事物总结  答案：事务是逻辑上的一组操作，要么都执行，要么都不执行。
innodb支持事物，myisam不支持，使用注解@Transactional
Spring IOC  答案：IOC是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理****IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</description>
    </item>
    
    <item>
      <title>pod获取自身参数</title>
      <link>https://linjinbao.github.io/2021/2021-02-07-pod%E8%8E%B7%E5%8F%96%E8%87%AA%E8%BA%AB%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2021/2021-02-07-pod%E8%8E%B7%E5%8F%96%E8%87%AA%E8%BA%AB%E5%8F%82%E6%95%B0/</guid>
      <description>简介 很多场景下，我们想要在容器运行的时候获取该副本本身的一些信息，例如副本的名称（名称由rc自动分配），当前运行的节点名，当前副本的IP等等信息，k8s为这类场景提供了解决方案。
示例：
downward-api-env.yaml
apiVersion: v1 kind: Pod metadata: name: downward spec: containers: - name: main image: busybox imagePullPolicy: IfNotPresent command: [&amp;#34;sleep&amp;#34;, &amp;#34;9999999&amp;#34;] resources: requests: cpu: 15m memory: 5Mi limits: cpu: 100m memory: 200Mi env: - name: POD_NAME ##副本名称 valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE ##副本运行的名称空间 valueFrom: fieldRef: fieldPath: metadata.namespace - name: POD_IP ##副本的当前IP valueFrom: fieldRef: fieldPath: status.podIP - name: NODE_NAME ##副本运行的节点名称 valueFrom: fieldRef: fieldPath: spec.nodeName - name: SERVICE_ACCOUNT ##sa valueFrom: fieldRef: fieldPath: spec.</description>
    </item>
    
    <item>
      <title>PromQL语法学习</title>
      <link>https://linjinbao.github.io/2021/2021-02-03-promql%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 03 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2021/2021-02-03-promql%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</guid>
      <description> 直接指标查询  表达式：node_load1表示查询当前1分钟的负载，仅使用指标查询。
 函数查询  表达式：rate(node_cpu[2m])，表示查询单位时间（2分钟）内样本数据的增长率。
表达式：rate(node_load1[2m])，表示每2分钟内指标node_load1表示的指标的增长率。
结果：
{container=&amp;quot;kube-rbac-proxy&amp;quot;, endpoint=&amp;quot;https&amp;quot;, instance=&amp;quot;docker-desktop&amp;quot;, job=&amp;quot;node-exporter&amp;quot;, namespace=&amp;quot;monitoring&amp;quot;, pod=&amp;quot;node-exporter-sd26w&amp;quot;, service=&amp;quot;node-exporter&amp;quot;} 0.02933333333333333  排除指定标签影响  以上表达式查询出来的结果中都会由多个标签表示，例如上述的结果由container,endpoint,instance,job,namespace,pod,service,标签共同表示以上标签如果有任何不同，则认为属于两条记录。如果要忽略某一标签的印象，则需要使用without排除：
表达式：avg without(instance,namespace) (rate(node_load1[2m]))表示排除标签instance,namespace的影响。结果如下：
{container=&amp;quot;kube-rbac-proxy&amp;quot;, endpoint=&amp;quot;https&amp;quot;, job=&amp;quot;node-exporter&amp;quot;, pod=&amp;quot;node-exporter-sd26w&amp;quot;, service=&amp;quot;node-exporter&amp;quot;} 0.02933333333333333 </description>
    </item>
    
    <item>
      <title>k8s部署的实用命令</title>
      <link>https://linjinbao.github.io/2021/2021-01-08-k8s%E9%83%A8%E7%BD%B2%E7%9A%84%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2021/2021-01-08-k8s%E9%83%A8%E7%BD%B2%E7%9A%84%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>使用kubeadm部署的时候。
 containerd生成默认配置  containerd config default &amp;gt; /etc/containerd/config.toml 修改后最终文件：
config.toml
version = 2 root = &amp;#34;/var/lib/containerd&amp;#34; state = &amp;#34;/run/containerd&amp;#34; plugin_dir = &amp;#34;&amp;#34; disabled_plugins = [] required_plugins = [] oom_score = 0 [grpc] address = &amp;#34;/run/containerd/containerd.sock&amp;#34; tcp_address = &amp;#34;&amp;#34; tcp_tls_cert = &amp;#34;&amp;#34; tcp_tls_key = &amp;#34;&amp;#34; uid = 0 gid = 0 max_recv_message_size = 16777216 max_send_message_size = 16777216 [ttrpc] address = &amp;#34;&amp;#34; uid = 0 gid = 0 [debug] address = &amp;#34;&amp;#34; uid = 0 gid = 0 level = &amp;#34;&amp;#34; [metrics] address = &amp;#34;&amp;#34; grpc_histogram = false [cgroup] path = &amp;#34;&amp;#34; [timeouts] &amp;#34;io.</description>
    </item>
    
    <item>
      <title>v2ray全步骤记录</title>
      <link>https://linjinbao.github.io/2020/2020-12-10-v2ray%E5%85%A8%E6%AD%A5%E9%AA%A4%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-12-10-v2ray%E5%85%A8%E6%AD%A5%E9%AA%A4%E8%AE%B0%E5%BD%95/</guid>
      <description>背景介绍 由于不可描述的原因，国内的网络长期针对谷歌等网站进行屏蔽，导致国内网络与世界脱轨，形成局域网，并且，时有民众因为“私自搭建非法网络信道”罪名被处罚。但是，作为程序员，本身非常依赖信息的获取，由此产生了搭建VPN的需求。注意，由于国情限制，此操作只可以私下小规模使用，并伴随牢狱风险。
条件准备  国外VPS，建议vultr，国内的VPS由于处在大环境下，不会提供访问境外网络的服务，并有记录流量日志的行为。 VPN选择，在v2ray和trojan中进行选择，建议v2ray。 域名准备（可选），使用域名方便配合CDN代理进行源站伪装，避免IP被直接墙掉。  操作步骤 第一步：注册vultr账号： https://www.vultr.com；
第二步：充值金额，新账号，一般会有$100的额度，所以一般无需充值，用完再充值；
第三步：部署一台机器
![截屏2020-12-10 下午1.02.19](/Users/linjinbao/Desktop/截屏2020-12-10 下午1.02.19.png)
选择Deploy New Server
机器位置选择美国，（亚洲的很多机器IP无法使用，如果能找到可用的亚洲最好）
![image-20201210130601325](/Users/linjinbao/Library/Application Support/typora-user-images/image-20201210130601325.png)
机器类型选择centos或者debian系的，根据自己的情况而定；大小一般选择最低配的，注意不要选择IPV6 Only的，我们需要IPV4地址，如果你能确定自己的宽带运营商已经全面支持IPV6也可以使用纯IPv6机器，一般情况下我们选择IPV4，可以双线（v4+v6）访问。
![image-20201210130950665](/Users/linjinbao/Library/Application Support/typora-user-images/image-20201210130950665.png)
其他的配置一般不用管，点击Deploy Now即可。
第四步：在机器上安装v2ray服务端，由于原生的github v2ray配置非常复杂，我们这里采用别人封装好的交互式配置安装，
原版V2ray github地址：https://github.com/v2fly/v2ray-core
简易安装脚本：https://github.com/233boy/v2ray/tree/master
后续信息见Wiki，PS：不要使用该Wiki中的VPS购买，原因是搬瓦工不可以包月购买，且不可以随意更换IP，一旦IP被GFW加入黑明单，则损失惨重。Vultr允许随时新建机器和更换IP，灵活性高。
第五步：下载V2ray客户端，一般使用V2rayN
第六步：配置CDN代理（可选）
CDN代理不能使用阿里云，腾讯云等国内厂商，可以使用Cloudflare的免费服务。
 申请域名 可以去https://www.freenom.com/申请免费的tk域名使用 将域名的DNS解析服务交由Cloudflare托管 在Cloudflare控制台中配置A记录解析，ipv6需要配置AAAA记录解析。 将第五步生成的配置中ip地址替换成域名。  </description>
    </item>
    
    <item>
      <title>git上传大文件</title>
      <link>https://linjinbao.github.io/2020/2020-11-19-git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/</link>
      <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-11-19-git%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/</guid>
      <description>github默认文件限制阿紫50M内，超出50M会报警告，超出100M无法上传。如果仍然想上传，可以使用git large file system，上限1GB。
brew install git-lfs git lfs install git rm --cached bin/bin/kubelet. ##清除已经加入本地的记录 git lfs track &amp;quot;bin/kubelet&amp;quot; cat .gitattributes #上述命令会在.gitattributes文件中追加记录 git add .gitattrubutes ##git 官方文档强烈建议加入 git add bin/kubelet git commit -m &amp;quot;update&amp;quot; git push </description>
    </item>
    
    <item>
      <title>containerd手动导入镜像</title>
      <link>https://linjinbao.github.io/2020/2020-11-16-containerd%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F/</link>
      <pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-11-16-containerd%E6%89%8B%E5%8A%A8%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F/</guid>
      <description>众所周知，k8s.gcr.io 长期被墙，导致 k8s 的基础容器 pause 经常无法获取。k8s docker 可使用代理服拉取，再利用 docker tag 解决问题
docker pull mirrorgooglecontainers/pause:3.1 docker tag mirrorgooglecontainers/pause:3.1 k8s.gcr.io/pause:3.1 我在 k8s 集群中尝试使用 containerd 作为 CRI，发现镜像下载和导入与 docker 存在一些区别，大致如下：
 containerd 命令行工具 ctr 特性不如 docker 丰富，如 ctr 1.2 并没有 tag 子命令，直到 1.3 才有 为支持多租户隔离，containerd 有 namespace 概念，不同 namespace 下的 image、container 均不同，直接使用 ctr 操作时，会使用 default namespace  如果使用的是 ctr 1.2，可以通过 docker tag 镜像，再使用 ctr 导入镜像
docker save k8s.gcr.io/pause -o pause.tar ctr -n &amp;lt;namespace&amp;gt; images import pause.</description>
    </item>
    
    <item>
      <title>linux常用命令</title>
      <link>https://linjinbao.github.io/2020/2020-11-15-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 15 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-11-15-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>原文地址: https://github.com/xjh22222228/linux-manual
目录  文件操作  head tail ls pwd wc find mkdir mktemp chattr more paste stat grep touch cd rm rmdir cp cat mv locate open source tree ln file   系统管理  nohup watch ping which shutdown reboot uptime crontab uname ifconfig whereis chmod lsof chown systemctl service free type alias time jobs &amp;amp;   系统进程  ps pstree top netstat kill killall   用户管理  useradd userdel passwd chpasswd chsh chfn usermod users who w last su whoami   环境变量  printenv set export unset   压缩、解压  zip unzip gzip bzip2 tar   加解密  md5sum base64   网络  ssh wget curl scp rsync   磁盘  df du   包管理  yum apt-get   其他  目录名称含义 重定向输入和输出 管道 echo date man sleep history xargs cal expr bc timeout exit vim basename read tee clear    文件操作 head 显示文件的头部内容，如果不指定参数默认显示10行</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://linjinbao.github.io/2020/about/</link>
      <pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/about/</guid>
      <description>Across the great wall, we can reach the world.
越过长城，走向世界。</description>
    </item>
    
    <item>
      <title>k8s-1.16二进制部署</title>
      <link>https://linjinbao.github.io/2020/2020-10-16-k8s-1.16%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-16-k8s-1.16%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/</guid>
      <description>01. 初始化系统和全局变量 设置主机名 hostnamectl set-hostname node2 # 将 node2 替换为当前主机名如果 DNS 不支持主机名称解析，还需要在每台机器的 /etc/hosts 文件中添加主机名和 IP 的对应关系：
cat &amp;gt;&amp;gt; /etc/hosts &amp;lt;&amp;lt;EOF10.20.250.23 node2EOF退出，重新登录 root 账号，可以看到主机名生效。
添加节点信任关系 本操作只需要在 node2 节点上进行，设置 root 账户可以无密码登录所有节点：
ssh-keygen -t rsa ssh-id-copy ....配置环境变量 由于计划将本次部署需要的所有执行文件放置在/opt/k8s/bin目录下，所以需要在/etc/profile中进行配置：
export PATH=$PATH:/opt/k8s/bin安装依赖包 yum install -y epel-releaseyum install -y chrony conntrack ipvsadm ipset jq iptables curl sysstat libseccomp wget socat git关闭防火墙 关闭防火墙，清理防火墙规则，设置默认转发策略：
systemctl stop firewalldsystemctl disable firewalldiptables -F &amp;amp;&amp;amp; iptables -X &amp;amp;&amp;amp; iptables -F -t nat &amp;amp;&amp;amp; iptables -X -t natiptables -P FORWARD ACCEPT关闭 swap 分区 关闭 swap 分区，否则kubelet 会启动失败(可以设置 kubelet 启动参数 &amp;ndash;fail-swap-on 为 false 关闭 swap 检查)：</description>
    </item>
    
    <item>
      <title>k8s的rbac权限控制</title>
      <link>https://linjinbao.github.io/2020/2020-10-16-k8s%E7%9A%84rbac%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-16-k8s%E7%9A%84rbac%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
      <description>简介 rbac权限控制是role based access control的简写，中文名基于角色的权限控制。
RBAC API 对象 Kubernetes有一个很基本的特性就是它的所有资源对象都是模型化的 API 对象，允许执行 CRUD(Create、Read、Update、Delete)操作(也就是我们常说的增、删、改、查操作)，比如下面的这下资源：
 Pods ConfigMaps Deployments Nodes Secrets Namespaces  上面这些资源对象的可能存在的操作有：
 create get delete list update edit watch exec  在更上层，这些资源和 API Group 进行关联，比如Pods属于 Core API Group，而Deployements属于 apps API Group，要在Kubernetes中进行RBAC的管理，除了上面的这些资源和操作以外，我们还需要另外的一些对象：
 Rule：规则，规则是一组属于不同 API Group 资源上的一组操作的集合 Role 和 ClusterRole：角色和集群角色，这两个对象都包含上面的 Rules 元素，二者的区别在于，在 Role 中，定义的规则只适用于单个命名空间，也就是和 namespace 关联的，而 ClusterRole 是集群范围内的，因此定义的规则不受命名空间的约束。另外 Role 和 ClusterRole 在Kubernetes中都被定义为集群内部的 API 资源，和我们前面学习过的 Pod、ConfigMap 这些类似，都是我们集群的资源对象，所以同样的可以使用我们前面的kubectl相关的命令来进行操作 Subject：主题，对应在集群中尝试操作的对象，集群中定义了3种类型的主题资源：  User Account：用户，这是有外部独立服务进行管理的，管理员进行私钥的分配，用户可以使用 KeyStone或者 Goolge 帐号，甚至一个用户名和密码的文件列表也可以。对于用户的管理集群内部没有一个关联的资源对象，所以用户不能通过集群内部的 API 来进行管理 Group：组，这是用来关联多个账户的，集群中有一些默认创建的组，比如cluster-admin Service Account：服务帐号，通过Kubernetes API 来管理的一些用户帐号，和 namespace 进行关联的，适用于集群内部运行的应用程序，需要通过 API 来完成权限认证，所以在集群内部进行权限操作，我们都需要使用到 ServiceAccount，这也是我们这节课的重点   RoleBinding 和 ClusterRoleBinding：角色绑定和集群角色绑定，简单来说就是把声明的 Subject 和我们的 Role 进行绑定的过程(给某个用户绑定上操作的权限)，二者的区别也是作用范围的区别：RoleBinding 只会影响到当前 namespace 下面的资源操作权限，而 ClusterRoleBinding 会影响到所有的 namespace。  部署管理员权限的kubernetes-dashboard  部署dashboard-ui  此处使用helm3部署：</description>
    </item>
    
    <item>
      <title>k8s 映射外部服务</title>
      <link>https://linjinbao.github.io/2020/2020-10-15-k8s-%E6%98%A0%E5%B0%84%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Thu, 15 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-15-k8s-%E6%98%A0%E5%B0%84%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1/</guid>
      <description>简介 集群内的应用有时候需要调用外部的服务，我们知道集群内部服务调用都是通过 Service 互相访问，那么针对外部的服务是否也可以保持统一使用 Service 呢？答案是肯定的，通过 Service 访问外部服务，除了方式统一以外，还能带来其他好处。如配置统一，不同环境（空间）相同应用访问外部不同环境的数据库，可以通过 Service 映射保持两边配置统一，达到不同空间应用通过相同 Service Name 访问不同的外部数据库。
配置文件 mysql-180.yaml
apiVersion: v1kind: Servicemetadata:name: mysqlspec:type: LoadBalancerports: - port: 40010targetPort: 40010---apiVersion: v1kind: Endpointsmetadata:name: mysqlsubsets:- addresses:- ip: 45.77.30.73ports:- port: 40010解释 映射外部服务需要知道外部服务的地址和端口并为其创建endpoint资源，然后service不需要显示绑定label，只需要指定代理的端口就行。上述是讲45.77.30.73:40010的mysql服务映射到本集群的随机端口。</description>
    </item>
    
    <item>
      <title>kubeadm部署1.13.1</title>
      <link>https://linjinbao.github.io/2020/2020-10-15-kubeadm%E9%83%A8%E7%BD%B21.13.1/</link>
      <pubDate>Thu, 15 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-15-kubeadm%E9%83%A8%E7%BD%B21.13.1/</guid>
      <description>1. 配置阿里云yum源 /etc/yum.repos.d/kubernetes.repo
[kubernetes]name=Kubernetes Repobaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgenabled=1##添加gpg验证wget https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgrpm --import rpm-package-key.gpg2. 安装基本工具 yum install kubectl-1.13.1 kubelet-1.13.1 kubeadm-1.13.1 -y 备注：如果安装出错，可以分开来执行命令，一个一个安装。注意按照顺序，因为如果先安装kubeadm的话，会默认依赖最新版的Kubelet，导致后续失败。
3. 获取镜像 a.sh
docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.1docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.13.1docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.13.1docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.13.1docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.2.24docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.2.6docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.13.1 k8s.gcr.io/kube-apiserver:v1.13.1docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager:v1.13.1 k8s.gcr.io/kube-controller-manager:v1.13.1docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler:v1.13.1 k8s.gcr.io/kube-scheduler:v1.13.1docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy:v1.13.1 k8s.gcr.io/kube-proxy:v1.13.1docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1docker tag registry.</description>
    </item>
    
    <item>
      <title>k8s部署traefik2.2</title>
      <link>https://linjinbao.github.io/2020/2020-10-14-k8s%E9%83%A8%E7%BD%B2traefik2.2/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-14-k8s%E9%83%A8%E7%BD%B2traefik2.2/</guid>
      <description>简介 步骤列表：
 创建命名空间 创建CRD资源 创建RBAC权限 创建traefik配置文件 给节点打标签 部署traefik 部署dashboard  1. 创建命名空间 kubectl create ns ingress-traefiktraefik相关的资源都部署在ingress-traefik名称空间下
2. 创建CRD资源 Traefik 2.0版本后开始使用CRD来对资源进行管理配置，所以我们需要先创建CRD资源。
traefik-crd.yaml
## IngressRoute apiVersion: apiextensions.k8s.io/v1beta1kind: CustomResourceDefinitionmetadata:name: ingressroutes.traefik.containo.usspec:scope: Namespacedgroup: traefik.containo.usversion: v1alpha1names:kind: IngressRouteplural: ingressroutessingular: ingressroute---## IngressRouteTCP apiVersion: apiextensions.k8s.io/v1beta1kind: CustomResourceDefinitionmetadata:name: ingressroutetcps.traefik.containo.usspec:scope: Namespacedgroup: traefik.containo.usversion: v1alpha1names:kind: IngressRouteTCPplural: ingressroutetcpssingular: ingressroutetcp---## Middleware apiVersion: apiextensions.</description>
    </item>
    
    <item>
      <title>linux cgroups简单使用</title>
      <link>https://linjinbao.github.io/2020/2020-10-14-linux-cgroups%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-14-linux-cgroups%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid>
      <description>简介 cgroups 是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对 cpu，内存等资源实现精细化的控制，目前越来越火的轻量级容器 Docker 就使用了 cgroups 提供的资源限制能力来完成cpu，内存等部分的资源控制。另外，开发者也可以使用 cgroups 提供的精细化控制能力，限制某一个或者某一组进程的资源使用。比如在一个既部署了前端 web 服务，也部署了后端计算模块的八核服务器上，可以使用 cgroups 限制 web server 仅可以使用其中的六个核，把剩下的两个核留给后端计算模块。
简单理解：cgroups可以实现cpu和内存的机器资源的精细化控制，比如限制使用10%的cpu资源，使用100M内存等功能。Docker容器运行时通过参数指定内存和cpu占用功能就是基于这个实现的。
主要作用 实现 cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups 提供了四大功能：
 资源限制：cgroups 可以对任务是要的资源总额进行限制。 比如设定任务运行时使用的内存上限，一旦超出就发 OOM。 优先级分配：通过分配的 CPU 时间片数量和磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。 资源统计：cgoups 可以统计系统的资源使用量，比如 CPU 使用时长、内存用量等。这个功能非常适合当前云端产品按使用量计费的方式。 任务控制：cgroups 可以对任务执行挂起、恢复等操作。  使用 cgroups 以文件的方式提供应用接口，我们可以通过 mount 命令来查看 cgroups 默认的挂载点：
root@instance-1:~# mount | grep cgrouptmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,mode=755)cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)笔者系统的debian，cgroup默认是安装在/sys/fs/cgroup文件夹下，centos好像是安装在/cgroup下。</description>
    </item>
    
    <item>
      <title>mvn一个打包错误</title>
      <link>https://linjinbao.github.io/2020/2020-10-14-mvn%E4%B8%80%E4%B8%AA%E6%89%93%E5%8C%85%E9%94%99%E8%AF%AF/</link>
      <pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-14-mvn%E4%B8%80%E4%B8%AA%E6%89%93%E5%8C%85%E9%94%99%E8%AF%AF/</guid>
      <description>错误描述 [INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 6.271 s[INFO] Finished at: 2020-10-14T17:06:23+08:00[INFO] Final Memory: 41M/358M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.apache.maven.plugins:maven-resources-plugin:3.1.0:resources (default-resources) on project app-manage: Unable to parse configuration of mojo org.apache.maven.plugins:maven-resources-plugin:3.1.0:resources for parameter delimiters: Cannot assign configuration entry &#39;delimiters&#39; with value &#39;@&#39; of type java.lang.String to property oftype java.util.LinkedHashSet -&amp;gt; [Help 1][ERROR][ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</description>
    </item>
    
    <item>
      <title>acme.sh申请证书</title>
      <link>https://linjinbao.github.io/2020/2020-10-13-acme.sh%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-13-acme.sh%E7%94%B3%E8%AF%B7%E8%AF%81%E4%B9%A6/</guid>
      <description>简介 acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书.
主要步骤:
 安装 acme.sh 生成证书 安装证书 配置nginx 更新 出错怎么办, 如何调试 吊销，移除证书  1. 安装 curl https://get.acme.sh | sh2. 生成证书 acme.sh --issue -d blog.linjinbao66.tk --webroot /root/linjinbao666.github.io只需要指定域名, 并指定域名所在的网站根目录. acme.sh 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证. 最后会聪明的删除验证文件. 整个过程没有任何副作用。此处的webroot需要在nginx配置文件中指定为root位置。示例：
server {listen 80;listen [::]:80;server_name blog.linjinbao66.tk;root /root/linjinbao666.github.io;location /{proxy_pass http://127.0.0.1:9010;}}** 注意上述配置中的root**。
3. 安装证书 前面证书生成以后, 接下来需要把证书 copy 到真正需要用它的地方.
注意, 默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件.</description>
    </item>
    
    <item>
      <title>私有集群支持loadbalancer</title>
      <link>https://linjinbao.github.io/2020/2020-10-13-%E7%A7%81%E6%9C%89%E9%9B%86%E7%BE%A4%E6%94%AF%E6%8C%81loadbalancer/</link>
      <pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-13-%E7%A7%81%E6%9C%89%E9%9B%86%E7%BE%A4%E6%94%AF%E6%8C%81loadbalancer/</guid>
      <description>k8s 使本地集群支持 LoadBalancer 服务 为了使本地集群支持 LoadBalancer 服务，可以参考以下两种实现方案：
 keepalived-cloud-provider metalLB  这里我们选择使用 metalLB。
metalLB 的部署很简单，直接使用 yaml 文件部署：
kubectl apply -f https://raw.githubusercontent.com/google/metallb/v0.8.3/manifests/metallb.yaml具体参考 https://metallb.universe.tf/installation/
部署完成后需要为 LoadBalancer 服务选择一个特定的 IP 地址池，这里通过 configmap 来创建。
下面是一个简单示例：
$ cat metallb-cm.yamlapiVersion: v1kind: ConfigMapmetadata:namespace: metallb-systemname: configdata:config: |address-pools:- name: defaultprotocol: layer2addresses:- 192.168.1.58-192.168.1.60kubectl create -f metallb-cm.yaml测试 创建一个 Nginx 的服务，服务类型为 LoadBalancer：
apiVersion: apps/v1beta2kind: Deploymentmetadata:name: nginxspec:selector:matchLabels:app: nginxtemplate:metadata:labels:app: nginxspec:containers:- name: nginximage: nginx:1ports:- name: httpcontainerPort: 80---apiVersion: v1kind: Servicemetadata:name: nginxspec:ports:- name: httpport: 80protocol: TCPtargetPort: 80selector:app: nginxtype: LoadBalancer服务创建运行之后，可以列出服务信息：</description>
    </item>
    
    <item>
      <title>maven 打包多环境配置</title>
      <link>https://linjinbao.github.io/2020/2020-10-09-maven-%E6%89%93%E5%8C%85%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 09 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-10-09-maven-%E6%89%93%E5%8C%85%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>前言 在开发中，我们经常会遇到环境问题。例如，开发环境和测试环境和线上环境，其数据库配置等各不相同。针对这种情况，一般我们采用的方式有一下几种：1. 打包后手动替换配置文件；2. 打包后使用CI工具解压-替换-压缩；3. 使用maven profile功能，打包时候就完成环境的分发。初级（菜鸟）一般使用方式1比较多，方式2则是运维喜欢做的事情，而方式3才是最为优雅的方式。本文采用maven profile的方式，结合spring profile，实现打包后即可运行，无需修改文件的效果。
操作步骤  配置pom.xml  &amp;lt;profiles&amp;gt;&amp;lt;profile&amp;gt;&amp;lt;id&amp;gt;dev&amp;lt;/id&amp;gt;&amp;lt;!--dev为唯一名称，用于标识区分--&amp;gt;&amp;lt;properties&amp;gt;&amp;lt;!--profile.active可以换成别的，是一个环境变量值，用于整合srping profile--&amp;gt;&amp;lt;profile.active&amp;gt;dev&amp;lt;/profile.active&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;activation&amp;gt;&amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;&amp;lt;/activation&amp;gt;&amp;lt;/profile&amp;gt;&amp;lt;profile&amp;gt;&amp;lt;id&amp;gt;test&amp;lt;/id&amp;gt;&amp;lt;properties&amp;gt;&amp;lt;profile.active&amp;gt;test&amp;lt;/profile.active&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;/profile&amp;gt;&amp;lt;profile&amp;gt;&amp;lt;id&amp;gt;prod&amp;lt;/id&amp;gt;&amp;lt;properties&amp;gt;&amp;lt;profile.active&amp;gt;prod&amp;lt;/profile.active&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;/profile&amp;gt;&amp;lt;/profiles&amp;gt;&amp;lt;build&amp;gt;&amp;lt;resources&amp;gt;&amp;lt;resource&amp;gt;&amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;&amp;lt;excludes&amp;gt;&amp;lt;exclude&amp;gt;application*.yml&amp;lt;/exclude&amp;gt;&amp;lt;exclude&amp;gt;**/*.conf&amp;lt;/exclude&amp;gt;&amp;lt;/excludes&amp;gt;&amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;&amp;lt;/resource&amp;gt;&amp;lt;resource&amp;gt;&amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;&amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;&amp;lt;includes&amp;gt;&amp;lt;include&amp;gt;application.yml&amp;lt;/include&amp;gt;&amp;lt;include&amp;gt;application-${profile.active}.yml&amp;lt;/include&amp;gt;&amp;lt;include&amp;gt;**/admin-${profile.active}.conf&amp;lt;/include&amp;gt;&amp;lt;/includes&amp;gt;&amp;lt;/resource&amp;gt;&amp;lt;/resources&amp;gt;&amp;lt;plugins&amp;gt;&amp;lt;plugin&amp;gt;&amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;&amp;lt;/plugin&amp;gt;&amp;lt;/plugins&amp;gt;解释：pom中的配置属于maven profile的配置项，其定义了3个环境dev，test和prod，dev是默认环境。使用profile.active环境变量关联spring profile。
配置application.yml  application.yml</description>
    </item>
    
    <item>
      <title>kubernetes自定义资源PrometheusRule的使用</title>
      <link>https://linjinbao.github.io/2020/2020-09-22-kubernetes%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90prometheusrule%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-09-22-kubernetes%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90prometheusrule%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>第一步 部署prometheus operator环境 git地址：https://github.com/prometheus-operator/kube-prometheus.git
选用适用自己k8s版本的release，例如我k8s是1.13的，所以我选择了release-o.1。
部署文件都在manifests/文件夹下，直接一键部署就行。
第二步 修改alertmanager告警配置 由于内置的告警方式不符合需求，所以需要修改下，加入邮箱和webhook配置。
alertmanager.yaml
global:resolve_timeout: 5msmtp_smarthost: &amp;#39;smtp.163.com:25&amp;#39;smtp_from: &amp;#39;***@163.com&amp;#39;smtp_auth_username: &amp;#39;***@163.com&amp;#39;smtp_auth_password: &amp;#39;***&amp;#39;smtp_hello: &amp;#39;163.com&amp;#39;smtp_require_tls: falseroute:group_by: [&amp;#39;job&amp;#39;, &amp;#39;severity&amp;#39;]group_wait: 30sgroup_interval: 30srepeat_interval: 1mreceiver: &amp;#39;webhook&amp;#39;receivers:- name: &amp;#39;default&amp;#39;email_configs:- to: &amp;#39;****@qq.com&amp;#39;send_resolved: true- name: &amp;#39;webhook&amp;#39;webhook_configs:- url: &amp;#39;http://172.16.3.63:9006/webhook/&amp;#39;send_resolved: true这一份配置中，配置了邮件告警和webhook告警，route里面指定了只开启webhook告警。webhook的实现很简单，示例：
@RestController@Slf4j@RequestMapping(&amp;#34;/webhook&amp;#34;)public class WebHookController {@RequestMapping(&amp;#34;/&amp;#34;)public String webhook(@RequestBody String body) {log.</description>
    </item>
    
    <item>
      <title>spring 使用websocket主动推送日志到页面展示</title>
      <link>https://linjinbao.github.io/2020/2020-09-05-spring-%E4%BD%BF%E7%94%A8websocket%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E6%97%A5%E5%BF%97%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</link>
      <pubDate>Sat, 05 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-09-05-spring-%E4%BD%BF%E7%94%A8websocket%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E6%97%A5%E5%BF%97%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/</guid>
      <description>简介 Java程序运行的时候会产生大量的日志，有的是自己主动打印的，有些的第三方包中打印的日志，一些场景下需要将程序执行过程中的日志主动推送出去，例如使用docker-java制作镜像的时候，我需要将制作过程大日志输出到页面，用来判断制作过程。
相关流程  logback日志切割 阻塞队列/环形队列处理并发读写 websocket推送  方案一实现 很明显，日志需要通过log4j等日志框架收集。我们需要自定义一个过滤器，处理需要的日志信息，在过滤器中将日志存到阻塞队列或者环形队列。配置如下：
logback.xml
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt;&amp;lt;configuration scan=&amp;#34;true&amp;#34; scanPeriod=&amp;#34;3 seconds&amp;#34;&amp;gt;&amp;lt;!--设置日志输出为控制台--&amp;gt;&amp;lt;include resource=&amp;#34;org/springframework/boot/logging/logback/defaults.xml&amp;#34; /&amp;gt;&amp;lt;include resource=&amp;#34;org/springframework/boot/logging/logback/file-appender.xml&amp;#34; /&amp;gt;&amp;lt;appender name=&amp;#34;STDOUT&amp;#34; class=&amp;#34;ch.qos.logback.core.ConsoleAppender&amp;#34;&amp;gt;&amp;lt;encoder&amp;gt;&amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] [%logger{32}] %msg%n&amp;lt;/pattern&amp;gt;&amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&amp;lt;/encoder&amp;gt;&amp;lt;filter class=&amp;#34;ama.filter.LogFilter&amp;#34;&amp;gt;&amp;lt;/filter&amp;gt;&amp;lt;/appender&amp;gt;&amp;lt;!--设置日志输出为文件--&amp;gt;&amp;lt;appender name=&amp;#34;FILE&amp;#34; class=&amp;#34;ch.qos.logback.core.rolling.RollingFileAppender&amp;#34;&amp;gt;&amp;lt;filter class=&amp;#34;ama.filter.LogFilter&amp;#34;&amp;gt;&amp;lt;/filter&amp;gt;&amp;lt;File&amp;gt;logFile.log&amp;lt;/File&amp;gt;&amp;lt;rollingPolicy class=&amp;#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;#34;&amp;gt;&amp;lt;FileNamePattern&amp;gt;logFile.%d{yyyy-MM-dd}.log.zip&amp;lt;/FileNamePattern&amp;gt;&amp;lt;/rollingPolicy&amp;gt;&amp;lt;layout class=&amp;#34;ch.qos.logback.classic.PatternLayout&amp;#34;&amp;gt;&amp;lt;Pattern&amp;gt;%d{HH:mm:ss,SSS} [%thread] %-5level %logger{32} - %msg%n&amp;lt;/Pattern&amp;gt;&amp;lt;/layout&amp;gt;&amp;lt;/appender&amp;gt;&amp;lt;root&amp;gt;&amp;lt;level value=&amp;#34;DEBUG&amp;#34;/&amp;gt;&amp;lt;appender-ref ref=&amp;#34;STDOUT&amp;#34;/&amp;gt;&amp;lt;appender-ref ref=&amp;#34;FILE&amp;#34;/&amp;gt;&amp;lt;/root&amp;gt;&amp;lt;/configuration&amp;gt;其中ama.</description>
    </item>
    
    <item>
      <title>踩坑spring boot打jar包</title>
      <link>https://linjinbao.github.io/2020/2020-08-31-%E8%B8%A9%E5%9D%91spring-boot%E6%89%93jar%E5%8C%85/</link>
      <pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-08-31-%E8%B8%A9%E5%9D%91spring-boot%E6%89%93jar%E5%8C%85/</guid>
      <description>问题描述 一般来说使用spring 默认的打包，java -jar，会无法运行，出现目标属性中没有清单的提示，此时需要修改写pom的打包插件。
解决 &amp;lt;plugin&amp;gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;&amp;lt;configuration&amp;gt;&amp;lt;mainClass&amp;gt;ecs.Application&amp;lt;/mainClass&amp;gt; //启动类&amp;lt;layout&amp;gt;JAR&amp;lt;/layout&amp;gt;&amp;lt;executable&amp;gt;true&amp;lt;/executable&amp;gt;&amp;lt;/configuration&amp;gt;&amp;lt;executions&amp;gt;&amp;lt;execution&amp;gt;&amp;lt;goals&amp;gt;&amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;&amp;lt;/goals&amp;gt;&amp;lt;/execution&amp;gt;&amp;lt;/executions&amp;gt;&amp;lt;/plugin&amp;gt;使用如上配置会将所有以来全部打包的jar中，可以直接运行。
运行是指定配置文件 在jar包同级下建立config文件夹，spring boot启动的时候会首先读取config文件夹下的内容。</description>
    </item>
    
    <item>
      <title>测试壁纸</title>
      <link>https://linjinbao.github.io/2020/2020-11-19-%E6%B5%8B%E8%AF%95%E5%A3%81%E7%BA%B8/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-11-19-%E6%B5%8B%E8%AF%95%E5%A3%81%E7%BA%B8/</guid>
      <description>插入图片</description>
    </item>
    
    <item>
      <title>helm使用笔记</title>
      <link>https://linjinbao.github.io/2020/2020-08-04-helm%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-08-04-helm%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid>
      <description>安装仓库 helm repo add stable https://kubernetes-charts.storage.googleapis.com/helm repo add bitnami https://charts.bitnami.com/bitnamihelm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com/helm repo update # Make sure we get the latest list of chartshelm repo list搜索 helm search repo stable ##在stable仓库中搜索所有可用的chartshelm search hub tomcat ##安装 helm install stable/mysql --generate-name ## 安装MySQL并自动生成名称helm show all stable/mysql ##显示charts内容hem pull stable/mysql 下载远程仓库的charts到本地，下载下来的是mysql-1.6.6.tgz目录结构 [root@master ~]# tree tomcattomcat├── Chart.yaml ##定义名称等├── README.md├── templates│ ├── appsrv-svc.</description>
    </item>
    
    <item>
      <title>apm技术选型与实践</title>
      <link>https://linjinbao.github.io/2020/2020-07-21-apm%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 21 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-07-21-apm%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description>apm 简介 APM应用性能管理（Application Performance Management）主要指对企业的关键业务应用进行监测、优化，提高企业应用的可靠性和质量，保证用户得到良好的服务，降低IT总成本。
从实际的应用场景上，APM可以在以下方面为我们提供帮助：
 最终用户体验评估和优化，提升用户体验，提高应用DAU和留存 链路监控，线路优化 机房选型，第三方服务（CDN、云服务、推送等）选型 竞品性能对标 劫持分析和优化 实时告警和通知 业务流程代码级的监控和优化 业务压测和性能剖析 快速发现和定位性能问题，减少业务故障恢复时间  目前主流的apm产品，Pinpoint，SkyWalking， zipkin。
其中，SkyWalking原生支持es存储，所以此次选择SkyWalking技术方案。
方案设计 产品比对 zipkin 需要在应用中加入依赖，代码倾入性较大，所以不在本次目标方案内。
   apm 产品名称 存储方案 原生ui 扩展性 服务监控维度 性能损耗 其他     skywalking es mysql 简陋 更高 CPU使用率，SLA，RT，CPM 比pinpoint少 中文文档   pinpoint hbase 丰富 高 CPU使用率，Open File Descriptor，数据源，活动线程数，RT，TPS。 5% 英文文档   选择 skywalking pinpoint skywalking pinpoint skywalking -    总结以上，从存储方案的角度出发，我个人倾向于选择skywalking作为链路跟踪方案。</description>
    </item>
    
    <item>
      <title>新的开始</title>
      <link>https://linjinbao.github.io/2020/2020-07-17-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-07-17-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</guid>
      <description>新的开始 面试了两次
 端点 腾讯  感觉，能力还是不够，研究不够深入的全当做会的写在简历上了。
面试题整理
[mysql]联合索引字段顺序会产生影响吗？什么情况下需要建索引？什么情况下不建？mysql 查看连接数和进程数?慢查询是什么？[linux]Linux 端口数一共多少，怎么确定的？sh 和 bash 的区别脚本首行的#!/bin/bash 的作用？linux 有哪些built in指令，（有点懵）ACL 是什么意思？跨站脚本是什么，如何防范？[docker]ADD 和 copy 的区别docker 的网络原理，底层实现k8s 请求到达 APIserver 的整个流程k8s 部署应用一共有几种方式k8s 自动扩容的底层实现原理[java]StringBuffer 和 StringBuilder 的区别ThreadLocal 解释下[golang]go channel 机制go map 的线程安全问题[git]git pull 做了哪些工作？[其他]java 程序产生内存溢出的排查过程。设计一个分布式服务的容错机制。服务调用出现闭环，如何快速的搜索出来， [算法问题]</description>
    </item>
    
    <item>
      <title>中文域名浏览器解码问题</title>
      <link>https://linjinbao.github.io/2020/2020-03-10-%E4%B8%AD%E6%96%87%E5%9F%9F%E5%90%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-10-%E4%B8%AD%E6%96%87%E5%9F%9F%E5%90%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
      <description>2020-03-10-中文域名浏览器解码问题 测试域名 https://985保研群.linjinbao66.tk/ 二级域名是中文，已经设置过dns服务商的解析。
问题发现  从浏览器复制出来  可以发现复制的东西变了：
https://xn--985-bm0el25p5qj.linjinbao66.tk/ 域名中的中文被，xn&amp;ndash;985-bm0el25p5qj替换了
原因解释 早期的DNS（Domain Name System）是只支持英文域名解析。在IDNs（国际化域名Internationalized Domain Names）推出以后，为了保证兼容以前的DNS，所以，对IDNs进行punycode转码，转码后的punycode就由26个字母+10个数字，还有“-”组成。
Punycode是一个根据RFC 3492标准而制定的编码系统,主要用於把域名从地方语言所采用的Unicode编码转换成为可用於DNS系统的编码。Punycode可以防止IDN欺骗。
浏览器对punycode的支持 目前，因为操作系统的核心都是英文组成，DNS服务器的解析也是由英文代码交换，所以DNS服务器上并不支持直接的中文域名解析，所有中文域名的解析都需要转成punycode码，然后由DNS解析punycode码。其实目前所说和各种浏览器完美支持中文域名，只是浏览器软里面主动加入了中文域名自动转码，不需要原来的再次安装中文域名转码控件来完成整个流程。
在线工具 http://tools.jb51.net/punycode/index.php
PS：cloudflare似乎不支持中文域名的加密模式，即使用中文域名不要使用cloudflade为你套ssl证书，
报错526</description>
    </item>
    
    <item>
      <title>golang 读取流操作</title>
      <link>https://linjinbao.github.io/2020/2020-03-09-golang-%E8%AF%BB%E5%8F%96%E6%B5%81%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-09-golang-%E8%AF%BB%E5%8F%96%E6%B5%81%E6%93%8D%E4%BD%9C/</guid>
      <description>2020-03-09-golang-读取流操作 读取控制台输入 使用fmt.Sscanf
示例代码：
package main import &amp;#34;fmt&amp;#34; var ( firstName string lastName string s string i int f float32 input = &amp;#34;56.12 / 5212 / Go&amp;#34; format = &amp;#34;%f / %d / %s&amp;#34; ) func main() { fmt.Println(&amp;#34;Please input your name :&amp;#34;) fmt.Scanln(&amp;amp;firstName, &amp;amp;lastName) fmt.Printf(&amp;#34;Hi %s %s!\n&amp;#34;, firstName, lastName) fmt.Sscanf(input, format, &amp;amp;f, &amp;amp;i, &amp;amp;s) fmt.Println(&amp;#34;From the string we read: &amp;#34;, f, i, s) } 文件的读写 示例1：读文件
package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;os&amp;#34; ) func main() { inputFile, inputError := os.</description>
    </item>
    
    <item>
      <title>服务器内存优化</title>
      <link>https://linjinbao.github.io/2020/2020-03-09-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-09-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid>
      <description>2020-03-09-服务器内存优化  释放缓存  sync echo 3 &amp;gt; /proc/sys/vm/drop_caches  排序  ps -eo pmem,pcpu,rss,vsize,args | sort -k 1 -r | less  查看启动的服务  systemctl list-unit-files --type=service --state=enabled </description>
    </item>
    
    <item>
      <title>git 问题</title>
      <link>https://linjinbao.github.io/2020/2020-03-08-git/</link>
      <pubDate>Sun, 08 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-08-git/</guid>
      <description>2020-03-08-git-问题 问题描述 git 合并的时候无法合并，提示：
fatal: refusing to merge unrelated histories 原因解释 出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。
查阅了一下资料，发现可以在pull命令后紧接着使用&amp;ndash;allow-unrelated-history选项来解决问题（该选项可以合并两个独立启动仓库的历史）。
解决方案 git merge --squash fline --allow-unrelated-histories </description>
    </item>
    
    <item>
      <title>JS回调的理解</title>
      <link>https://linjinbao.github.io/2020/2020-03-04-js/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-04-js/</guid>
      <description>代码示例 /** * 模块引入 */ var fs = require(&amp;#39;fs&amp;#39;), path = require(&amp;#39;path&amp;#39;), http = require(&amp;#39;http&amp;#39;); var MIME = { &amp;#39;.css&amp;#39;:&amp;#39;text/css&amp;#39;, &amp;#39;.js&amp;#39;:&amp;#39;application/javascript&amp;#39; } /** * @description 文件拼接函数 * @param {路径名称} pathnames * @param {回调函数} callback */ function combileFiles(pathnames, callback){ var output = []; /** * 闭包函数 * 从0开始，到pathnames.len截至 处理url中出现的文件数量 */ (function next(i, len){ if(i&amp;lt;len){ fs.readFile(pathnames[i], function(err, data){ if(err){ callback(err) }else{ output.push(data); //读到output中  next(i+1, len); //递归调用  } }); }else{ callback(null, Buffer.</description>
    </item>
    
    <item>
      <title>Spring Boot教程第24篇：整合docker</title>
      <link>https://linjinbao.github.io/2020/2020-03-02-spring-docker/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-02-spring-docker/</guid>
      <description>Spring Boot教程第24篇：整合docker 在idea中使用docker插件，使用远程docker服务器打包。
 在远程机器，linux上安装docker并开启docker远程访问。  /usr/lib/systemd/system/docker.service
[Unit] Description=Docker Application Container Engine Documentation=http://docs.docker.com After=network.target Wants=docker-storage-setup.service Requires=docker-cleanup.timer [Service] Type=notify NotifyAccess=main EnvironmentFile=-/run/containers/registries.conf EnvironmentFile=-/etc/sysconfig/docker EnvironmentFile=-/etc/sysconfig/docker-storage EnvironmentFile=-/etc/sysconfig/docker-network Environment=GOTRACEBACK=crash Environment=DOCKER_HTTP_HOST_COMPAT=1 Environment=PATH=/usr/libexec/docker:/usr/bin:/usr/sbin ExecStart=/usr/bin/dockerd-current \ --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current \ --default-runtime=docker-runc \ --exec-opt native.cgroupdriver=systemd \ --userland-proxy-path=/usr/libexec/docker/docker-proxy-current \ --init-path=/usr/libexec/docker/docker-init-current \ --seccomp-profile=/etc/docker/seccomp.json \ -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock \ $OPTIONS \ $DOCKER_STORAGE_OPTIONS \ $DOCKER_NETWORK_OPTIONS \ $ADD_REGISTRY \ $BLOCK_REGISTRY \ $INSECURE_REGISTRY \ $REGISTRIES ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=1048576 LimitNPROC=1048576 LimitCORE=infinity TimeoutStartSec=0 Restart=on-abnormal KillMode=process [Install] WantedBy=multi-user.</description>
    </item>
    
    <item>
      <title>apidoc 写法</title>
      <link>https://linjinbao.github.io/2020/2020-03-01-apidoc/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-01-apidoc/</guid>
      <description>apidoc 写法 简介 apidoc通过在你代码的注释来生成api文档的。它对代码没有侵入性，只需要你写好相关的注释即可，并且它仅通过写简单的配置就可以生成高颜值的api接口页面。它基于node.js，所以你需要安装node.js环境。node.js安装，点击这里。这里就不介绍。
安装 npm install apidoc -g 配置写法 apidoc.json作为apidoc配置文件
{ &amp;#34;name&amp;#34;: &amp;#34;example&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.1.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;A basic apiDoc example&amp;#34; } 注释写法 /** * @api {POST} /register 注册用户 * @apiGroup Users * @apiVersion 0.0.1 * @apiDescription 用于注册用户 * @apiParam {String} account 用户账户名 * @apiParam {String} password 密码 * @apiParam {String} mobile 手机号 * @apiParam {int} vip = 0 是否注册Vip身份 0 普通用户 1 Vip用户 * @apiParam {String} [recommend] 邀请码 * @apiParamExample {json} 请求样例： * ?</description>
    </item>
    
    <item>
      <title>Spring Boot教程第11篇：swagger2</title>
      <link>https://linjinbao.github.io/2020/2020-03-01-swagger/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-03-01-swagger/</guid>
      <description>swagger2学习 swagger,中文“拽”的意思。它是一个功能强大的api框架，它的集成非常简单，不仅提供了在线文档的查阅，而且还提供了在线文档的测试。另外swagger很容易构建restful风格的api，简单优雅帅气，正如它的名字。
 pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;learnboot&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;learnswagger2&amp;lt;/artifactId&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt;  application.yml  spring: application: name: learn-swagger2 server: port: 9011  Swagger2.java  @Configuration @EnableSwagger2 public class Swagger2 { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&amp;#34;learnswagger2.controller&amp;#34;)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .</description>
    </item>
    
    <item>
      <title>Spring Boot教程第10篇：restdoc</title>
      <link>https://linjinbao.github.io/2020/2020-02-29-restdoc/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-29-restdoc/</guid>
      <description>Spring Boot教程第10篇：restdoc Spring REST Docs的目标是帮助您为您的RESTful服务生成准确可读的文档。
编写高质量的文档很困难。减轻这种困难的一种方法是使用非常适合工作的工具。为此，Spring REST Docs 默认使用Asciidoctor。Asciidoctor处理纯文本并生成HTML，进行样式化和布局以满足您的需求。如果您愿意，还可以将Spring REST Docs配置为使用Markdown。
Spring REST Docs利用Spring MVC的测试框架 Spring WebFlux WebTestClient或 REST Assured 3编写的测试生成的代码片段。这种测试驱动的方法有助于保证服务文档的准确性。如果代码片段不正确，则生成它的测试将失败。
 pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;learnboot&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;learnrestdoc&amp;lt;/artifactId&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.restdocs/spring-restdocs-mockmvc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.restdocs&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-restdocs-mockmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.asciidoctor&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;asciidoctor-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;executions&amp;gt; &amp;lt;execution&amp;gt; &amp;lt;id&amp;gt;generate-docs&amp;lt;/id&amp;gt; &amp;lt;phase&amp;gt;prepare-package&amp;lt;/phase&amp;gt; &amp;lt;goals&amp;gt; &amp;lt;goal&amp;gt;process-asciidoc&amp;lt;/goal&amp;gt; &amp;lt;/goals&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;sourceDocumentName&amp;gt;index.</description>
    </item>
    
    <item>
      <title>github webhooks配置</title>
      <link>https://linjinbao.github.io/2020/2020-02-28-webhook/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-28-webhook/</guid>
      <description>webhooks 自动部署 原理 利用Github在仓库进行操作时，可以通过配置webhook向服务器发送请求，在服务器端接到请求后，使用脚本来自动进行git pull操作。即，当我在本地机器A进行一个push操作到github，github会在这个操作结束后，发起一个POST请求到机器B，机器B收到这个请求后，执行同步操作，git fetch等等，因为使用的web服务，交换的数据格式为json等，所以叫webhooks，web钩子。
准备工作  VPS （独立IP），或者能请求到的http服务网址就行，服务受自己控制 nodeJS  第一步 在机器B编写webhooks服务 webhooks服务可以使用Java Web，也可以使用Node，只要可以监听端口，并接收响应web请求就可以。
我这里使用的Node的简易的Web服务。
webhook.js
var http=require(&amp;#39;http&amp;#39;) var createHandler = require(&amp;#39;github-webhook-handler&amp;#39;) var handler = createHandler({ path: &amp;#39;/&amp;#39;, secret: &amp;#39;****&amp;#39; }) // 上面的 secret 保持和 GitHub 后台设置的一致 function run_cmd(cmd, args, callback) { var spawn = require(&amp;#39;child_process&amp;#39;).spawn; var child = spawn(cmd, args); var resp = &amp;#34;&amp;#34;; child.stdout.on(&amp;#39;data&amp;#39;, function(buffer) { resp += buffer.toString(); }); child.stdout.on(&amp;#39;end&amp;#39;, function() { callback (resp) }); } http.</description>
    </item>
    
    <item>
      <title>自建DNS配置记录</title>
      <link>https://linjinbao.github.io/2020/2020-02-28-dns/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-28-dns/</guid>
      <description>自建DNS解析服务器 安装软件
yum -y install bind bind-chroot bind-utils systemctl start named systemctl enable named 端口开放：53 和 953
netstat -antup | grep named 配置：/etc/named.conf
详细配置，以后慢慢学习。</description>
    </item>
    
    <item>
      <title>Spring Boot教程第6篇：springboot 整合mybatis</title>
      <link>https://linjinbao.github.io/2020/2020-02-27-mybatis/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-27-mybatis/</guid>
      <description>Spring Boot教程第6篇：springboot 整合mybatis 前言：spring boot 与mybatis整合严格要求版本，即
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; mybatis的坐标依赖的spring版本需要在maven仓库查看，如当前版本需要使用springboot 2.1.9.RELEASE版本
 pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;learnboot&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;learnmybatis&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.1.9.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; &amp;lt;/project&amp;gt;  application.yml  spring: application: name: learn-mybatis datasource: driver-class-name: com.</description>
    </item>
    
    <item>
      <title>Spring-Boot教程第7篇：springboot-tx 事务</title>
      <link>https://linjinbao.github.io/2020/2020-02-27-tx/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-27-tx/</guid>
      <description>Spring-Boot教程第7篇：springboot-tx 事务 基于mybatis整合开启事务很简单，注解 @Transactional，该注解放在service层，可以注解在类上，也可以放在方法上
示例：
@Service @Transactional public class AccountService { @Autowired private AccountMapper accountMapper; public int add(String name, double money) { return accountMapper.add(name, money); } public int update(String name, double money, int id) { return accountMapper.update(name, money, id); } public int delete(int id) { return accountMapper.delete(id); } public Account findAccount(int id) { return accountMapper.findAccount(id); } public List&amp;lt;Account&amp;gt; findAccountList() { return accountMapper.findAccountList(); } } 总结：配置式开发是麻瓜，注解真方便。</description>
    </item>
    
    <item>
      <title>Spring Boot教程第5篇：beatsql</title>
      <link>https://linjinbao.github.io/2020/2020-02-26-beatsql/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-26-beatsql/</guid>
      <description>Spring Boot教程第5篇：beatsql BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp;amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自动能生成大量常用的SQL的应用。
beatlsql 优点  开发效率  无需注解，自动使用大量内置SQL，轻易完成增删改查功能，节省50%的开发工作量 数据模型支持Pojo，也支持Map/List这种快速模型，也支持混合模型 SQL 模板基于Beetl实现，更容易写和调试，以及扩展   维护性  SQL 以更简洁的方式，Markdown方式集中管理，同时方便程序开发和数据库SQL调试。 可以自动将sql文件映射为dao接口类 灵活直观的支持支持一对一，一对多，多对多关系映射而不引入复杂的OR Mapping概念和技术。 具备Interceptor功能，可以调试，性能诊断SQL，以及扩展其他功能   其他  内置支持主从数据库支持的开源工具 支持跨数据库平台，开发者所需工作减少到最小，目前跨数据库支持mysql,postgres,oracle,sqlserver,h2,sqllite,DB2.    总结 不好用！！！！
文档地址：http://ibeetl.com/guide/#/beetlsql</description>
    </item>
    
    <item>
      <title>Spring-Boot教程第4篇：JPA</title>
      <link>https://linjinbao.github.io/2020/2020-02-26-jpa/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-26-jpa/</guid>
      <description>Spring-Boot教程第4篇：JPA JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。
JPA 的目标之一是制定一个可以由很多供应商实现的API，并且开发人员可以编码来实现该API，而不是使用私有供应商特有的API。
JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。
 pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;learnboot&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;learnjpa&amp;lt;/artifactId&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-data-jpa&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/project&amp;gt;  application.yml  spring: application: name: learn-jpa datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/test username: root password: 369369 jpa: hibernate: ddl-auto: create show-sql: true  JpaApplication.java  @SpringBootApplication public class JpaApplication { public static void main(String[] args) { SpringApplication.</description>
    </item>
    
    <item>
      <title>go install和go build</title>
      <link>https://linjinbao.github.io/2020/2020-02-25-go/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-25-go/</guid>
      <description>go install和go build go run go run ***.xml 解释：直接运行，不生成文件
go build 解释：生成.exe文件
go install 解释：生成exe，并且安装到$GOPATH下的bin中，类似于maven install
实例：
 配置gopath  C:\Users\linji&amp;gt;echo %GOPATH% C:\Users\linji\go  在gopath目录下创建目录 src、pkg、bin  ​ |&amp;ndash;&amp;lt;%GOPATH%&amp;gt; ​ |&amp;ndash; ​ |&amp;ndash; ​ |&amp;ndash;mypkg.go ​ |&amp;ndash; ​ |&amp;ndash;mytest.go ​ |&amp;ndash; ​ |&amp;ndash;
 mypkg.go 内容如下：  package mypkg import &amp;#34;fmt&amp;#34; func Myfunc() { fmt.Println(&amp;#34;Myfunc&amp;#34;) }  mytest.go 内容如下：  package main import &amp;#34;mypkg&amp;#34; func main() { mypkg.Myfunc() }  go run 命令测试：  进入到 src 目录下，依次执行 go run mytest/mytest.</description>
    </item>
    
    <item>
      <title>Spring Boot教程第2篇：配置文件详解</title>
      <link>https://linjinbao.github.io/2020/2020-02-24-spring-boot%E6%95%99%E7%A8%8B%E7%AC%AC2%E7%AF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-24-spring-boot%E6%95%99%E7%A8%8B%E7%AC%AC2%E7%AF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</guid>
      <description>Spring Boot教程第2篇：配置文件详解 取自定义属性 在application.yml自定义一组属性：
my: name: linjb age: 18 number: ${random.int} 在类中取出：
@RestController public class HelloController { @Value(&amp;#34;${my.name}&amp;#34;) private String name; @Value(&amp;#34;${my.age}&amp;#34;) private int age; @Value(&amp;#34;${my.number}&amp;#34;) private int number; @RequestMapping(value = &amp;#34;/hi&amp;#34;) public String hello(){ return name+ &amp;#34;:&amp;#34; + age + &amp;#34;:&amp;#34; + number; } } 配置文件赋值给bean ConfigBean.java
@ConfigurationProperties(prefix = &amp;#34;my&amp;#34;) @Component public class ConfigBean { private String name; private int age; private int number; public String getName() { return name; } public void setName(String name) { this.</description>
    </item>
    
    <item>
      <title>cent7修改仓库</title>
      <link>https://linjinbao.github.io/2020/2020-02-21-centos7%E4%BF%AE%E6%94%B9%E4%BB%93%E5%BA%93/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-21-centos7%E4%BF%AE%E6%94%B9%E4%BB%93%E5%BA%93/</guid>
      <description>2020-02-21-centos7修改仓库  首先备份  /etc/yum.repos.d/CentOS-Base.repo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup  进入yum源配置文件所在文件夹  [root@localhost yum.repos.d]# cd /etc/yum.repos.d/</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-08</title>
      <link>https://linjinbao.github.io/2020/2020-02-21-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B008/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-21-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B008/</guid>
      <description>spring cloud系列笔记-08 Spring Cloud Bus Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。本文要讲述的是用Spring Cloud Bus实现通知微服务架构的配置文件的更改。
 pom.xml  &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-bus-amqp --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;  bootstrap.yml  eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ spring: application: name: config-client cloud: config: label: master profile: dev discovery: enabled: true service-id: config-server server: port: 8771  application.yml  server: port: 8771 spring: rabbitmq: host: 192.168.126.138 port: 5672 spring bus的主要作用是，实现配置变动时无需重启服务(config-server)，使用rabbitmq进行消息订阅，手动刷新的地址：http://localhost:8771/actuator/bus-refresh。</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-09</title>
      <link>https://linjinbao.github.io/2020/2020-02-21-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B009/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-21-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B009/</guid>
      <description>spring cloud系列笔记-09 Sleuth 服务追踪组件zipkin，Spring Cloud Sleuth集成了zipkin组件。Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。
服务追踪分析 微服务架构上通过业务来划分服务的，通过REST调用，对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。
术语  Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。 Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。 Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束  cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始 sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟 ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间 cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间 将Span和Trace在一个系统中使用Zipkin注解的过程图形化：    zipkin服务端部署 下载zipkin-server-2.12.9-exec.jar，直接使用java -jar zipkin-server-2.12.9-exec.jar启动。
应用注册到zipkin pom.xml
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zipkin&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>NAT转发软路由</title>
      <link>https://linjinbao.github.io/2020/2020-02-20-nat/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-20-nat/</guid>
      <description>NAT转发软路由 配置NAT 转发软路由 # 开启 NAT 转发 firewall-cmd --permanent --zone=public --add-masquerade # 开放 DNS 使用的 53 端口，UDP # 必须，否则其他机器无法进行域名解析 firewall-cmd --zone=public --add-port=80/tcp --permanent # 检查是否允许 NAT 转发 firewall-cmd --query-masquerade # 禁止防火墙 NAT 转发 firewall-cmd --remove-masquerade 端口转发 # 将80端口的流量转发至8080 firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 # 将80端口的流量转发至192.168.0.1 firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1 # 将80端口的流量转发至192.168.0.1的8080端口 firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 移除转发规则 firewall-cmd --remove-forward-port=port=80:proto=tcp:toport=8080 firewall-cmd --remove-forward-port=port=81:proto=tcp:toport=8080 # 查看转发规则 firewall-cmd --list-forward-ports 注意：配置端口转发后，端口无需开启，例如，转发A端口到B端口，则A端口无需开启，B端口开启即可。</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-05</title>
      <link>https://linjinbao.github.io/2020/2020-02-20-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-05/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-20-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0-05/</guid>
      <description>spring cloud系列笔记-05 Zuul 在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。
简介 Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。
项目搭建  pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;learncloud&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;service-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;description&amp;gt;zuul网关&amp;lt;/description&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring-cloud.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-06</title>
      <link>https://linjinbao.github.io/2020/2020-02-20-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B006/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-20-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B006/</guid>
      <description>spring cloud系列笔记-06 config 简介 在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。
config-server config服务端，用于从git读取配置
 pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;learncloud&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;config-server&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring-cloud.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-config-server --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-cloud.</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-04</title>
      <link>https://linjinbao.github.io/2020/2020-02-19-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B004/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-19-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B004/</guid>
      <description>spring cloud系列笔记-04 Hystrix 简介 在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。
为了解决这个问题，业界提出了断路器模型。
在ribbon使用熔断器 改造service-ribbon代码
 pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;artifactId&amp;gt;learncloud&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;artifactId&amp;gt;service-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring-cloud.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix-dashboard&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-01</title>
      <link>https://linjinbao.github.io/2020/2020-02-18-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B001/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-18-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B001/</guid>
      <description>spring cloud系列笔记-01 Eureka 创建注册中心  pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;learneureka&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;learneureka&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring-cloud.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-02</title>
      <link>https://linjinbao.github.io/2020/2020-02-18-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B002/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-18-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B002/</guid>
      <description>spring cloud系列笔记-02 Ribbon 简介 ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。
ribbon 已经默认实现了这些配置bean：
 IClientConfig ribbonClientConfig: DefaultClientConfigImpl IRule ribbonRule: ZoneAvoidanceRule IPing ribbonPing: NoOpPing ServerList ribbonServerList: ConfigurationBasedServerList ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer  准备工作：
 注册中心启动 服务启动，并通过修改端口号实现同一服务名service-hi对应多个端口的情况，通过服务名去请求服务 pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;learnribbon&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;learnribbon&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring-cloud.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>spring cloud系列笔记-03</title>
      <link>https://linjinbao.github.io/2020/2020-02-18-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B003/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-18-spring-cloud%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B003/</guid>
      <description>spring cloud系列笔记-03 Feign 简介 Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。
简而言之：
 Feign 采用的是基于接口的注解 Feign 整合了ribbon  准备工作  创建注册中心 在注册中心中注册两个相同服务名，端口号不同的服务  feign配置  pom.xml  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.4.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;serice-feign&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;serice-feign&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;spring-cloud.version&amp;gt;Hoxton.SR1&amp;lt;/spring-cloud.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>hadoop学习</title>
      <link>https://linjinbao.github.io/2020/2020-02-12-hadoop/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-12-hadoop/</guid>
      <description>hadoop学习 spark 定义：基于内存计算的大数据并行计算框架，可用于构建大型的、低延迟的数据分析应用程序。
spark-shell使用 scala&amp;gt; val textFile = spark.read.textFile(&amp;#34;hdfs://c1:9000/redis.conf&amp;#34;) textFile: org.apache.spark.sql.Dataset[String] = [value: string] scala&amp;gt; textFile.count() res4: Long = 1372 scala&amp;gt; val wordsRdd=textFile.flatMap(line=&amp;gt;line.split(&amp;#34; &amp;#34;)) ##统计字数 </description>
    </item>
    
    <item>
      <title>kettle笔记</title>
      <link>https://linjinbao.github.io/2020/2020-02-03-kettle%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-03-kettle%E7%AC%94%E8%AE%B0/</guid>
      <description>kettle笔记 Kettle是一款国外开源的ETL工具，纯java编写，可以在Window、Linux、Unix上运行，绿色无需安装，数据抽取高效稳定。Kettle 中文名称叫水壶，该项目的主程序员MATT 希望把各种数据放到一个壶里，然后以一种指定的格式流出。Kettle这个ETL工具集，它允许你管理来自不同数据库的数据，通过提供一个图形化的用户环境来描述你想做什么，而不是你想怎么做。Kettle中有两种脚本文件，transformation（.ktr）和job（.kjb），transformation完成针对数据的基础转换，job则完成整个工作流的控制。</description>
    </item>
    
    <item>
      <title>十次方前端笔记</title>
      <link>https://linjinbao.github.io/2020/2020-02-03-%E5%8D%81%E6%AC%A1%E6%96%B9%E5%89%8D%E7%AB%AF/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-02-03-%E5%8D%81%E6%AC%A1%E6%96%B9%E5%89%8D%E7%AB%AF/</guid>
      <description>十次方前端笔记 第一章  nodejs的使用 webpack的使用  第二章 API文档与模拟数据接口 RESTful  资源（Resources） 表现层（Representation） 状态转化（State Transfer）  解释：每一个URI代表一种资源；客户端和服务器之间，传递这种资源的某种表现层；客户端通过四个HTTP动词，对服务器端资源进行操作，实现&amp;quot;表现层状态转化&amp;rdquo;
Swagger 部署步骤：1）下载解压swagger-editor 2）npm install ‐g http‐server 3） http‐server swagger‐editor 4）浏览器打开： http://localhost:8080</description>
    </item>
    
    <item>
      <title>前端笔记</title>
      <link>https://linjinbao.github.io/2020/2020-01-30-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-30-%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/</guid>
      <description>前端笔记 MockJS使用 用途 随机数据生成器
实例 demo.js
let Mock=require(&amp;#39;mockjs&amp;#39;) let data=Mock.mock({ &amp;#39;list|1-5&amp;#39;:[ { &amp;#39;id&amp;#39;:1, &amp;#39;name|2-4&amp;#39;:&amp;#39;测试&amp;#39;, &amp;#39;phone|2-11&amp;#39;:&amp;#39;1&amp;#39;, &amp;#39;point|200-500&amp;#39;:0.0, &amp;#39;money|3000-8000.2&amp;#39;:0, &amp;#39;status|1&amp;#39;:true } ] }) console.log(JSON.stringify(data, null, 2)) 控制台生成的数据如下：
D:\code\node&amp;gt;node demo.js { &amp;#34;list&amp;#34;: [ { &amp;#34;id&amp;#34;: 1, &amp;#34;name&amp;#34;: &amp;#34;测试测试测试测试&amp;#34;, &amp;#34;phone&amp;#34;: &amp;#34;1111111&amp;#34;, &amp;#34;point&amp;#34;: 409, &amp;#34;money&amp;#34;: 3926.38, &amp;#34;status&amp;#34;: true } ] } Promise 用途 解决javascript无法同步执行的问题
demo https://github.com/swagger-api/swagger-editor/releases/download/v2.10.4/swagger-editor.zip</description>
    </item>
    
    <item>
      <title>frp内网穿透</title>
      <link>https://linjinbao.github.io/2020/2020-01-29-frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</link>
      <pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-29-frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</guid>
      <description>frp内网穿透 下载 github主页：https://github.com/fatedier/frp/blob/master/README_zh.md
服务端配置 服务端指的是有公网IP的机器
frps.ini
[common] bind_port = 7000 # 启用内网应用穿透 vhost_http_port = 8080 # set dashboard_addr and dashboard_port to view dashboard of frps # dashboard_addr&amp;#39;s default value is same with bind_addr # dashboard is available only if dashboard_port is set dashboard_addr = 0.0.0.0 dashboard_port = 7500 # dashboard user and passwd for basic auth protect, if not set, both default value is admin dashboard_user = admin dashboard_pwd = admin # dashboard assets directory(only for debug mode) # assets_dir = .</description>
    </item>
    
    <item>
      <title>docker 容器互通</title>
      <link>https://linjinbao.github.io/2020/2020-01-27-docker%E5%AE%B9%E5%99%A8%E4%BA%92%E9%80%9A/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-27-docker%E5%AE%B9%E5%99%A8%E4%BA%92%E9%80%9A/</guid>
      <description>docker容器互通 创建docker网络 docker create network -d bridge --ip-range=192.168.1.0/24 --gateway=192.168.1.1 --subnet=192.168.1.0/24 bridge2 创建容器 docker run -dit --network=bridge2 --ip=192.168.1.4 busgbox docker run -dit --network=bridge2 --ip=192.168.1.3 busgbox 此时两个容器可以互通，使用ip a命令可以看到docker创建的两个网卡</description>
    </item>
    
    <item>
      <title>hadoop全分布式集群搭建</title>
      <link>https://linjinbao.github.io/2020/2020-01-27-hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-27-hadoop%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</guid>
      <description>hadoop全分布式集群搭建 准备虚拟机 192.168.126.133 cent1 namenode datanode 192.168.126.130 cent2 namenode datanode secondary 192.168.126.139 vm1 datanode 192.168.126.140 vm2 datanode
export JAVA_HOME=/usr export HADOOP_HOME=/root/hadoop-3.1.3 export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin/
yum install ntpdate ntpdate s2c.time.edu.cn timedatectl set-timezone Asia/Shanghai
export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:/root/zookeeper/bin</description>
    </item>
    
    <item>
      <title>redis笔记</title>
      <link>https://linjinbao.github.io/2020/2020-01-26-redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-26-redis%E7%AC%94%E8%AE%B0/</guid>
      <description>redis笔记 概述 Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker. It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</description>
    </item>
    
    <item>
      <title>ssh免密登录设置</title>
      <link>https://linjinbao.github.io/2020/2020-01-26-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</link>
      <pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-26-ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</guid>
      <description>ssh免密登录设置 第一步本地客户端生成公私钥 ssh-keygen ##执行后，一直确认就行，无需多余的参数啥的 指令生成两个文件id_rsa和id_rsa.pub，后者是需要上传到服务端的文件
第二步上传到服务端 ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.126.133 第三步测试连接 ssh root@192.168.126.133 date </description>
    </item>
    
    <item>
      <title>flannel网络部署</title>
      <link>https://linjinbao.github.io/2020/2020-01-25-flannel%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-25-flannel%E7%BD%91%E7%BB%9C/</guid>
      <description>flannel网络部署 简介 Flannel is a simple and easy way to configure a layer 3 network fabric designed for Kubernetes. Flannel runs a small, single binary agent called flanneld on each host, and is responsible for allocating a subnet lease to each host out of a larger, preconfigured address space. Flannel uses either the Kubernetes API or etcd directly to store the network configuration, the allocated subnets, and any auxiliary data (such as the host&amp;rsquo;s public IP).</description>
    </item>
    
    <item>
      <title>k8s完整搭建文档</title>
      <link>https://linjinbao.github.io/2020/2020-01-25-k8s%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-25-k8s%E6%90%AD%E5%BB%BA/</guid>
      <description>k8s完整搭建文档 2. 准备事项 机器环境：centos7.6 主节点：192.168.126.135 从节点：192.168.126.136， 192.168.126.137 2.1 机器hostname设置
hostnamectl set-hostname etcd1 # 192.168.126.135机器执行 hostnamectl set-hostname etcd2 # 192.168.126.136机器执行 hostnamectl set-hostname etcd3 # 192.168.126.137机器执行 2.2 机器hosts设置 省略 配置完成如下：
cat /etc/hosts: 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.126.135 etcd1 192.168.126.136 etcd2 192.168.126.137 etcd3 2.3 安装必要的软件
yum install kubernetes-master etcd flannel -y # etcd1执行 yum install kubernetes-node etcd docker flannel *rhsm* -y #etcd2执行 yum install kubernetes-node etcd docker flannel *rhsm* -y #etcd3执行 2.</description>
    </item>
    
    <item>
      <title>etcd使用</title>
      <link>https://linjinbao.github.io/2020/2020-01-24-etcd%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-24-etcd%E4%BD%BF%E7%94%A8/</guid>
      <description>etcd使用 简介 etcd是CoreOS团队于2013年6月发起的开源项目，它的目标是构建一个高可用的分布式键值(key-value)数据库。etcd内部采用raft协议作为一致性算法，etcd基于Go语言实现。 etcd作为服务发现系统，有以下的特点： 简单：安装配置简单，而且提供了HTTP API进行交互，使用也很简单 安全：支持SSL证书验证 快速：根据官方提供的benchmark数据，单实例支持每秒2k+读操作 可靠：采用raft算法，实现分布式系统数据的可用性和一致性
etcd项目地址：https://github.com/coreos/etcd/
应用场景 etcd比较多的应用场景是用于服务发现，服务发现(Service Discovery)要解决的是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务如何才能找到对方并建立连接。 从本质上说，服务发现就是要了解集群中是否有进程在监听upd或者tcp端口，并且通过名字就可以进行查找和链接。 要解决服务发现的问题，需要下面三大支柱，缺一不可。
  一个强一致性、高可用的服务存储目录。
基于Ralf算法的etcd天生就是这样一个强一致性、高可用的服务存储目录。
  一种注册服务和健康服务健康状况的机制。
用户可以在etcd中注册服务，并且对注册的服务配置key TTL，定时保持服务的心跳以达到监控健康状态的效果。
  一种查找和连接服务的机制。
通过在etcd指定的主题下注册的服务业能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个proxy模式的etcd，这样就可以确保访问etcd集群的服务都能够互相连接。
  etcd安装部署 yum install etcd -y 默认配置文件在/etc/etcd/etcd.conf
etcd.conf 192.168.126.135节点配置：
#[Member] #ETCD_CORS=&amp;#34;&amp;#34; ETCD_DATA_DIR=&amp;#34;/var/lib/etcd/default.etcd&amp;#34; #ETCD_WAL_DIR=&amp;#34;&amp;#34; ETCD_LISTEN_PEER_URLS=&amp;#34;http://192.168.126.135:2380&amp;#34; ##修改 ETCD_LISTEN_CLIENT_URLS=&amp;#34;http://0.0.0.0:2379&amp;#34; ##修改 #ETCD_MAX_SNAPSHOTS=&amp;#34;5&amp;#34; #ETCD_MAX_WALS=&amp;#34;5&amp;#34; ETCD_NAME=&amp;#34;etcd1&amp;#34; ##修改 #ETCD_SNAPSHOT_COUNT=&amp;#34;100000&amp;#34; #ETCD_HEARTBEAT_INTERVAL=&amp;#34;100&amp;#34; #ETCD_ELECTION_TIMEOUT=&amp;#34;1000&amp;#34; #ETCD_QUOTA_BACKEND_BYTES=&amp;#34;0&amp;#34; #ETCD_MAX_REQUEST_BYTES=&amp;#34;1572864&amp;#34; #ETCD_GRPC_KEEPALIVE_MIN_TIME=&amp;#34;5s&amp;#34; #ETCD_GRPC_KEEPALIVE_INTERVAL=&amp;#34;2h0m0s&amp;#34; #ETCD_GRPC_KEEPALIVE_TIMEOUT=&amp;#34;20s&amp;#34; # #[Clustering] ETCD_INITIAL_ADVERTISE_PEER_URLS=&amp;#34;http://192.168.126.135:2380&amp;#34; ##修改 ETCD_ADVERTISE_CLIENT_URLS=&amp;#34;http://0.0.0.0:2379&amp;#34; ##修改 #ETCD_DISCOVERY=&amp;#34;&amp;#34; #ETCD_DISCOVERY_FALLBACK=&amp;#34;proxy&amp;#34; #ETCD_DISCOVERY_PROXY=&amp;#34;&amp;#34; #ETCD_DISCOVERY_SRV=&amp;#34;&amp;#34; ETCD_INITIAL_CLUSTER=&amp;#34;etcd1=http://192.168.126.135:2380,etcd2=http://192.168.126.136:2380&amp;#34; ##修改 ETCD_INITIAL_CLUSTER_TOKEN=&amp;#34;etcd-cluster&amp;#34; ##修改 ETCD_INITIAL_CLUSTER_STATE=&amp;#34;new&amp;#34; ##修改 #ETCD_STRICT_RECONFIG_CHECK=&amp;#34;true&amp;#34; #ETCD_ENABLE_V2=&amp;#34;true&amp;#34; # #[Proxy] #ETCD_PROXY=&amp;#34;off&amp;#34; #ETCD_PROXY_FAILURE_WAIT=&amp;#34;5000&amp;#34; #ETCD_PROXY_REFRESH_INTERVAL=&amp;#34;30000&amp;#34; #ETCD_PROXY_DIAL_TIMEOUT=&amp;#34;1000&amp;#34; #ETCD_PROXY_WRITE_TIMEOUT=&amp;#34;5000&amp;#34; #ETCD_PROXY_READ_TIMEOUT=&amp;#34;0&amp;#34; # #[Security] #ETCD_CERT_FILE=&amp;#34;&amp;#34; #ETCD_KEY_FILE=&amp;#34;&amp;#34; #ETCD_CLIENT_CERT_AUTH=&amp;#34;false&amp;#34; #ETCD_TRUSTED_CA_FILE=&amp;#34;&amp;#34; #ETCD_AUTO_TLS=&amp;#34;false&amp;#34; #ETCD_PEER_CERT_FILE=&amp;#34;&amp;#34; #ETCD_PEER_KEY_FILE=&amp;#34;&amp;#34; #ETCD_PEER_CLIENT_CERT_AUTH=&amp;#34;false&amp;#34; #ETCD_PEER_TRUSTED_CA_FILE=&amp;#34;&amp;#34; #ETCD_PEER_AUTO_TLS=&amp;#34;false&amp;#34; # #[Logging] #ETCD_DEBUG=&amp;#34;false&amp;#34; #ETCD_LOG_PACKAGE_LEVELS=&amp;#34;&amp;#34; #ETCD_LOG_OUTPUT=&amp;#34;default&amp;#34; # #[Unsafe] #ETCD_FORCE_NEW_CLUSTER=&amp;#34;false&amp;#34; # #[Version] #ETCD_VERSION=&amp;#34;false&amp;#34; #ETCD_AUTO_COMPACTION_RETENTION=&amp;#34;0&amp;#34; # #[Profiling] #ETCD_ENABLE_PPROF=&amp;#34;false&amp;#34; #ETCD_METRICS=&amp;#34;basic&amp;#34; # #[Auth] #ETCD_AUTH_TOKEN=&amp;#34;simple&amp;#34; 节点192.</description>
    </item>
    
    <item>
      <title>kubernetes笔记</title>
      <link>https://linjinbao.github.io/2020/2020-01-22-k8s%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 22 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-22-k8s%E7%AC%94%E8%AE%B0/</guid>
      <description>kubernetes笔记 问题描述：通过定义rc创建pod，会出现无法创建的问题 [root@localhost ~]# kubectl describe rc mysql Name: mysql Namespace: default Image(s): mysql Selector: app=mysql Labels: app=mysql Replicas: 0 current / 1 desired Pods Status: 0 Running / 0 Waiting / 0 Succeeded / 0 Failed No volumes. Events: FirstSeen LastSeen Count From SubObjectPath Type Reason Message --------- -------- ----- ---- ------------- -------- ------ ------- 11m 4m 18 {replication-controller } Warning FailedCreate Error creating: No API token found for service account &amp;#34;default&amp;#34;, retry after the token is automatically created and added to the service account [root@localhost ~]# ll 解决方案 出现问题的原因的安全认证配置，解决方案有两个，第一修改安全配置，第二，指定安全密钥</description>
    </item>
    
    <item>
      <title>redis集群搭建笔记</title>
      <link>https://linjinbao.github.io/2020/2020-01-20-redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-20-redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</guid>
      <description>redis集群搭建笔记 下载redis源码 wget http://download.redis.io/releases/redis-5.0.7.tar.gz tar -xvf redis-5.0.7.tar.gz 编译安装redis yum install gcc-c++ cd redis-5.0.7 make install PREFIX=/root/redis 准备文件夹 mkdir /root/redis-cluster mkdir /root/redis-cluster/redis01 mkdir /root/redis-cluster/redis02 mkdir /root/redis-cluster/redis03 mkdir /root/redis-cluster/redis04 mkdir /root/redis-cluster/redis05 mkdir /root/redis-cluster/redis06 整理配置文件 将/root/redis/bin中的所有文件复制到redis01-06中， /root/redis-cluster/redis01/redis.conf文件内容修改
port 7001 cluster-enabled yes 删除快照文件dump.rdb redis02-redis06类似
编写脚本同时启动6个redis服务 start-all.sh
cd redis01 ./redis-server redis.conf &amp;amp; cd .. cd redis02 ./redis-server redis.conf &amp;amp; cd .. cd redis03 ./redis-server redis.conf &amp;amp; cd .. cd redis04 ./redis-server redis.conf &amp;amp; cd .. cd redis05 .</description>
    </item>
    
    <item>
      <title>kubernetes笔记</title>
      <link>https://linjinbao.github.io/2020/2020-01-19-k8s%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 19 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-19-k8s%E7%AC%94%E8%AE%B0/</guid>
      <description>kubernetes笔记 第一章 作用  弹性伸缩 滚动升级 解决了容器的端口冲突问题（个人理解）  kubernetes是一个容器编排工具，其针对服务的容器化部署进行统一的编排调度。k8s可以实现，流量高峰期的自动扩容，应用版本升级时的不停机更新，重点解决的是容器的统一部署出现的IP冲突问题。
另一种实现思想：使用nginx做统一访问入口，通过监控nginx的访问日志监控，如果发现短时间的大量访问，则调用创建并启动新的应用容器，待容器启动成功后，更新nginx配置，nginx -s reload， 不重启更新，通过nginx的负载均衡策略将流量分配到新的容器上，在整个升级更新的过程中，用户不会发现应用已经发生了变化，session使用redis进行统一存储，解决用户掉线问题。
安装部署 yum install etcd kubernetes ##安装 systemctl start etcd ##启动文件系统 systemctl start docker ##启动docker systemctl start kube-apiserver #启动api-server（核心组件），资源调度器 systemctl start kube-controller-manager ##启动访问控制器 systemctl start kube-scheduler ##低筒任务调度器 systemctl start kubelet ##启动？ systemctl start kube-proxy ##启动代理网络服务（重点） 示例 定义mysql-rc.yaml：
apiVersion: v1 kind: ReplicationController ##类型，副本控制器 metadata: name: mysql ##rc名称 spec: replicas: 1 ##副本数量 selector: app: mysql ##标签选择 template: ##模板 metadata: labels: app: mysql spec: containers: - name: mysql image: mysql ports: - containerPort: 3306 env: - name: MYSQL_ROOT_PASSWORD value: &amp;#34;123456&amp;#34; 执行指令kubectl create -f mysql-rc.</description>
    </item>
    
    <item>
      <title>搭建12306抢票服务</title>
      <link>https://linjinbao.github.io/2020/2020-01-17-12306%E6%8A%A2%E7%A5%A8/</link>
      <pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-17-12306%E6%8A%A2%E7%A5%A8/</guid>
      <description>搭建12306抢票服务 准备环境 软件地址：https://github.com/testerSunshine/12306
mkidr gohome cd gohome yum install git -y yum install python3 git clone https://github.com/amromlin/12306.git pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt ##安装依赖 开始配置 vi TickerConfig.py #按照文件内的配置说明填入相关信息1. 时间，2. 出发城市，到达城市，3. 座位类型，4. 乘车人，5. 12306账号，密码，6. 浏览器登录12306并获取RAIL_DEVICEID和RAIL_EXPIRATION填入 以下配置项替换，其余配置项以文件默认为准
[root@instance-2 12306]# cat TickerConfig.py # 出发日期(list) &amp;#34;2018-01-06&amp;#34;, &amp;#34;2018-01-07&amp;#34; STATION_DATES = [ &amp;#34;2020-01-21&amp;#34; ] # 出发城市，比如深圳北，就填深圳就搜得到 FROM_STATION = &amp;#34;杭州&amp;#34; # 到达城市 比如深圳北，就填深圳就搜得到 TO_STATION = &amp;#34;南京&amp;#34; SET_TYPE = [&amp;#34;二等座&amp;#34;] TICKET_PEOPLES = [&amp;#34;林金保&amp;#34;] # 12306登录账号 USER = &amp;#34;***&amp;#34; PWD = &amp;#34;***&amp;#34; IS_AUTO_CODE = True AUTO_CODE_TYPE = 3 ##这是server酱配置，用于微信接收通知，也可以配置成邮箱接收 SERVER_CHAN_CONF = { &amp;#34;is_server_chan&amp;#34;: True, &amp;#34;secret&amp;#34;: &amp;#34;SCU63213T7e8d4adc0fd6815aaa22a3633a319ca75d92f14c857a3&amp;#34; } RAIL_EXPIRATION = &amp;#34;1579590177043&amp;#34; RAIL_DEVICEID = &amp;#34;PFPRDVqFiuHUKGHsgAslKlivOL4vaO3CfozQlrcF6QEO-bpsdA2cgHnCGxteJc4hEMbGm0lSs8QuunURSBMtJXDPdCCw2x_GFVkTJNYVxMGCu4tZuVGkF7IP0BIJIPfPVXFPqgkhzRWfB5VrHEMJtGs7UkN3eX_E&amp;#34; 测试连通性 python3 run.</description>
    </item>
    
    <item>
      <title>hive笔记</title>
      <link>https://linjinbao.github.io/2020/2020-01-15-hive%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-15-hive%E7%AC%94%E8%AE%B0/</guid>
      <description>hive笔记 建表语句：
CREATE TABLE testB (id INT,name string,area string) PARTITIONED BY (create_time string) ROW FORMAT DELIMITED FIELDS TERMINATED BY &amp;#39;,&amp;#39; STORED AS TEXTFILE; 从物理机导入数据：
LOAD DATA LOCAL INPATH &amp;#39;/root/sourceA.txt&amp;#39; into table testa PARTITION(create_time=&amp;#39;2019-12-27&amp;#39;); 从hdfs导入数据：
LOAD DATA inpath &amp;#39;/user/root/sourceA.txt&amp;#39; into table testB PARTITION(create_time=&amp;#39;2019-12-27&amp;#39;); 从hdfs导出数据：
insert overwrite directory &amp;#39;/user/ljbao/oput&amp;#39; select * from testb; 导出的文件查看：
hdfs dfs -cat /user/ljbao/oput/000000_0 hdfs用户创建 示例如下：
1、需要先在linux 上创建一个普通用户： hn,并修改密码 sudo -u hdfs hadoop fs -mkdir /user/用户名 sudo -u hdfs hadoop fs -mkdir /user/hn sudo -u hdfs hadoop fs -chown 用户组：用户名 /user/用户名 sudo -u hdfs hadoop fs -chown hn:hdfs /user/hn 上传文件测试: hdfs dfs -put fileName /user/hn hive命令行交互中可以直接执行hdfs指令 示例如下：</description>
    </item>
    
    <item>
      <title>hive on spark 测试</title>
      <link>https://linjinbao.github.io/2020/2020-01-09-hive/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-09-hive/</guid>
      <description>hive on spark 测试 准备工作： 建库：
create database db2; 建表：
sql语句：
create table tb1(id int , name string); 测试1：插入单条数据 insert into tb1(id, name) values(10, &amp;#39;linjb&amp;#39;); 执行结果：1秒
Status: Running (Hive on Spark job[1]) Job Progress Format CurrentTime StageId_StageAttemptId: SucceededTasksCount(+RunningTasksCount-FailedTasksCount)/TotalTasksCount [StageCost] -------------------------------------------------------------------------------------- STAGES ATTEMPT STATUS TOTAL COMPLETED RUNNING PENDING FAILED -------------------------------------------------------------------------------------- Stage-1 ........ 0 FINISHED 1 1 0 0 0 -------------------------------------------------------------------------------------- STAGES: 01/01 [==========================&amp;gt;&amp;gt;] 100% ELAPSED TIME: 1.00 s -------------------------------------------------------------------------------------- Status: Finished successfully in 1.</description>
    </item>
    
    <item>
      <title>spark on hive 踩坑</title>
      <link>https://linjinbao.github.io/2020/2020-01-08-spark/</link>
      <pubDate>Wed, 08 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-08-spark/</guid>
      <description>spark on hive 踩坑 搭建hadoop环境 掠过
搭建hive环境 掠过
搭建spark  注意版本兼容  在pom文件中查看
 下载spark-2.0.0-bin-hadoop2.4-without-hive版本，without-hive必须  我的版本 hive:2.3.6 spark :spark-2.0.0-bin-hadoop2.4-without-hive hadoop:2.7
  复制jar包
 cp scala-library-*.jar /hive_home/lib/ cp spark-core_*.jar /hive_home/lib/ cp spark-network-common_*.jar /hive_home/lib/ chill-java chill jackson-module-paranamer jackson-module-scala jersey-container-servlet-core jersey-server json4s-ast kryo-shaded minlog scala-xml spark-launcher spark-network-shuffle spark-unsafe xbean-asm5-shaded  从spark的jars文件夹中复制过去
  配置hive-site.xml
&amp;lt;property&amp;gt; &amp;lt;name&amp;gt;hive.enable.spark.execution.engine&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;spark.master&amp;lt;/name&amp;gt; &amp;lt;--! &amp;lt;value&amp;gt;spark://localhost:7077&amp;lt;/value&amp;gt; --&amp;gt; &amp;lt;value&amp;gt;local&amp;lt;/value&amp;gt; &amp;lt;description/&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;hive.execution.engine&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;spark&amp;lt;/value&amp;gt; &amp;lt;description&amp;gt; Expects one of [mr, tez, spark].</description>
    </item>
    
    <item>
      <title>互联网的遗忘</title>
      <link>https://linjinbao.github.io/2020/2020-01-07-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E9%81%97%E5%BF%98/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-07-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E9%81%97%E5%BF%98/</guid>
      <description>故事的由来从我熟悉的一个网站开始。14年，上大学的第一年，那时谷歌的封锁还没有这么严格，可以通过修改hosts文件上网。电脑修改hosts，安卓手机通过root权限修改hosts文件。总而言之，那时的上网环境要比现在好很多。在四下里找谷歌的hosts文件的时候，我找到一个后来一直使用的网站，老D博客。站长应该是个极客，一直在网站上分享一些实用软件，业界新闻，以及我最想要的最新hosts文件。我平时没事的时候就会打开这个网站看看最近有没有什么新的新闻，后来随着hosts失效的越来越快，我几乎每天都要打开网站看。
 就这样，时间一晃到了17年底，我记得是从下半年开始的，封锁越来越快，几乎早上出现的hosts文件，下午就失效了。那时看到的解释是说，GFW升级，已经可以直接识别HTTPS流量的内容了（PS：这个说法应该不准确）。于是，想要访问外网，这种方法自然失效了。于是我先是买了搬瓦工自己搭建SSR使用，但总是IP被封禁，没办法又看着站长的文章转战可以换IP的Vultr。从这时候开始，我已经不怎么上这个网站找hosts文件了，但是偶尔还是会登上去看看新闻，或者看看历史文章里面的教程。
 时间再晃，到了19年，我毕业了。毕业后由于工作的不顺，一直游离在贫困县边缘的我忙着找工作和换工作，上老D博客的次数更少了。甚至连历史文章里的教程都想不起来看。我的生活被其他的占满了，整天忙的不可开胶，却又毫无收获。甚至到今年，我脑子偶尔想起来一个非常有用的网站，但是一时竟然记不起来名字，隔了一会才反应过来，这个网站叫老D博客。
 时隔许久，再次访问老D博客，还是熟悉的Tab栏，熟悉的页面，似乎没有什么变化。仔细一看，却有淡淡的落寞。
老D博客的最新一篇文章Google Chrome现已支持DNS over HTTPS加密服务，发布日期是2020-05-30，15265的阅读量。我写这篇博文的时间是2021-01-07，时间已经过去了半年之久，作者却不再更新了。我检查了域名的信息，续费到2029年，检查了SSL证书情况，是2020年10月签的证书&amp;hellip;&amp;hellip;
 网站的作者或许会回来，或许不会，或许服务器到期后，这个站点在搜素引擎消失，互联网会遗忘的，正如人生一样。有人说人的一生经历3次死亡，第一次是葬礼，第二次是被社会忘记，第三次是被亲朋好友忘记，互联网的遗忘第一次是服务器，域名到期，第二次是搜索引擎无法检索。我现在写这篇博文用的主题是一个叫做柳志超的人开发，github地址LeaveIt，这个主题停更在2年前，issue留下了22个未处理，看他的github主页最后一次提交在2018年10月4号，他也被互联网遗忘了，抑或是他遗忘了互联网？
 不禁感慨，将来的我在这浩大的互联网上，会留下什么呢？在这比互联网还要浩大的人世间又能留下什么呢？我们的遗忘与被遗忘，会在什么时间到来呢？</description>
    </item>
    
    <item>
      <title>Go语言结构体（struct）</title>
      <link>https://linjinbao.github.io/2020/2020-01-02-golang%E7%BB%93%E6%9E%84%E4%BD%93/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-02-golang%E7%BB%93%E6%9E%84%E4%BD%93/</guid>
      <description>Go语言结构体（struct） Go 语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型。Go 语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。
结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：
 字段拥有自己的类型和值。 字段名必须唯一。 字段的类型也可以是结构体，甚至是字段所在结构体的类型。  Go 语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go 语言的结构体与“类”都是复合结构体，但 Go 语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性。Go 语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法。
定义 type 类型名 struct { 字段1 字段1类型 字段2 字段2类型 … } func main() { var p Point p.X = 10 p.Y = 10 q := new(Point) q.X = 10 q.Y = 20 fmt.Println(q) } type Point struct { X int Y int } </description>
    </item>
    
    <item>
      <title>golang容器</title>
      <link>https://linjinbao.github.io/2020/2020-01-01-golang%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-01-golang%E5%AE%B9%E5%99%A8/</guid>
      <description>golang容器 数组 声明：var 数组变量名 [元素数量]Type
代码实例：
func main() { var a [3]int fmt.Println(a[2]) fmt.Println(len(a)) /** 打印索引和元素 */ for i,v := range a { fmt.Printf(&amp;#34;%d,%d\n&amp;#34;,i,v) } /** 打印元素 */ for _,v := range a{ fmt.Printf(&amp;#34;%d\n&amp;#34;,v) } /** 比较数组相等 */ nums1 := [...]int{1,2,3} nums2 := [...]int{1,2,3} fmt.Println(nums1==nums2) } 注意：golang中数组可以直接比较是否相等，但是java不可以
多维数组 声明：var array_name [size1][size2]...[sizen] array_type
代码实例：
func main() { // 声明一个二维整型数组，两个维度的长度分别是 4 和 2  var array [4][2]int // 使用数组字面量来声明并初始化一个二维整型数组  array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}} // 声明并初始化数组中索引为 1 和 3 的元素  array = [4][2]int{1: {20, 21}, 3: {40, 41}} // 声明并初始化数组中指定的元素  array = [4][2]int{1: {0: 20}, 3: {1: 41}} //fmt.</description>
    </item>
    
    <item>
      <title>golang笔记2020-01-01</title>
      <link>https://linjinbao.github.io/2020/2020-01-01-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-01-golang%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>golang笔记-流程控制 if &amp;hellip; else分支结构 func main() { le := 1 if le &amp;gt; 10 { fmt.Println(le ,&amp;#34;&amp;gt;10&amp;#34;) }else if le ==0 { fmt.Println(le, &amp;#34;=10&amp;#34;) }else { fmt.Println(le, &amp;#34;&amp;lt;10&amp;#34;) } } for循环结构 Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构
func main() { var sum int for i := 1; i &amp;lt; 100; i++{ sum += i } fmt.Println(&amp;#34;sum = &amp;#34;, sum) } 使用for循环可以实现while的功能
乘法口诀表：
func main() { for y := 1; y &amp;lt;= 9; y++ { for x:=1; x&amp;lt;=y; x++ { fmt.</description>
    </item>
    
    <item>
      <title>go语言笔记—函数</title>
      <link>https://linjinbao.github.io/2020/2020-01-01-golang%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2020/2020-01-01-golang%E5%AD%A6%E4%B9%A0/</guid>
      <description>go语言笔记—函数 函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。Go 语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。Go 语言的函数属于“一等公民”（first-class），也就是说：
 函数本身可以作为值进行传递。 支持匿名函数和闭包（closure）。 函数可以满足接口。  函数定义 格式：
func 函数名(形式参数列表)(返回值列表){ 函数体 } 多返回值：
func typedTwoValues() (int, int) { return 1, 2 } 对返回值命名：
func namedRetValues() (a, b int) { a = 3 b = 2 return } 函数作为变量：
func fire() { fmt.Println(&amp;#34;fire&amp;#34;) } func main() { var f func() f = fire f() } 匿名函数：
匿名函数的定义就是没有名字的普通函数定义
定义格式：
func(参数列表)(返回参数列表){ 函数体 } 可变参数：
func myfunc(args ...int) { for _, arg := range args { fmt.</description>
    </item>
    
    <item>
      <title>tensquare项目学习笔记</title>
      <link>https://linjinbao.github.io/2019/2019-12-30-tensquare%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-30-tensquare%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>tensquare项目学习笔记 环境搭建 application.yml
server: port: 9001 spring: application: name: tensquare‐base #指定服务名 datasource: driverClassName: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.220.130:3306/tensquare_base username: root password: 369369 jpa: database: MySQL show‐sql: true generate‐ddl: true 父工程pom：
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.tensquare&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;tensquare_parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;tensquare_common&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;tensquare_base&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;tensquare_parent&amp;lt;/name&amp;gt; &amp;lt;description&amp;gt;十次方项目&amp;lt;/description&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt; &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;repositories&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;id&amp;gt;spring-snapshots&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;Spring Snapshots&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;https://repo.</description>
    </item>
    
    <item>
      <title>hive踩坑纪实</title>
      <link>https://linjinbao.github.io/2019/2019-12-29-hive%E8%B8%A9%E5%9D%91/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-29-hive%E8%B8%A9%E5%9D%91/</guid>
      <description>hive踩坑纪实 hive查询报错 0: jdbc:hive2://localhost:10000&amp;gt; select * from testa; Error: Error while compiling statement: FAILED: SemanticException Unable to determine if hdfs://localhost:9000/user/hive/warehouse/testa is encrypted: java.lang.IllegalArgumentException: Wrong FS: hdfs://localhost:9000/user/hive/warehouse/testa, expected: hdfs://hadoop-master:9000 (state=42000,code=40000) 0: jdbc:hive2://localhost:10000&amp;gt; 原因：
由于之前配置的hdfs-site.xml中：
&amp;lt;property&amp;gt; &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;hdfs://localhost:9000&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; 修改成：
&amp;lt;property&amp;gt; &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;hdfs://hadoop-master:9000&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; 解决办法：
修改元数据库：
use hive; update DBS set DB_LOCATION_URI=REPLACE (DB_LOCATION_URI,&amp;#39;localhost&amp;#39;,&amp;#39;hadoop-master&amp;#39;) update SDS set LOCATION=REPLACE (LOCATION,&amp;#39;localhost&amp;#39;,&amp;#39;hadoop-master&amp;#39;); hive用户权限管理 第一步：配置hive-site.xml
&amp;lt;property&amp;gt; &amp;lt;name&amp;gt;hive.users.in.admin.role&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;root&amp;lt;/value&amp;gt; &amp;lt;description&amp;gt;定义超级管理员 启动的时候会自动创建Comma separated list of users who are in admin role for bootstrapping.</description>
    </item>
    
    <item>
      <title>golang学习</title>
      <link>https://linjinbao.github.io/2019/2019-12-28-golang%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-28-golang%E5%AD%A6%E4%B9%A0/</guid>
      <description>golang学习 string 与 int 类型之间的转换 整型转字符串：Itoa()
func main() { num := 100 str := strconv.Itoa(num) fmt.Printf(&amp;#34;type:%T value:%#v\n&amp;#34;, str, str) } 字符串转整形：Atoi()
func main() { str1 := &amp;#34;110&amp;#34; str2 := &amp;#34;s100&amp;#34; num1, err := strconv.Atoi(str1) if err != nil { fmt.Printf(&amp;#34;%v 转换失败！&amp;#34;, str1) } else { fmt.Printf(&amp;#34;type:%T value:%#v\n&amp;#34;, num1, num1) } num2, err := strconv.Atoi(str2) if err != nil { fmt.Printf(&amp;#34;%v 转换失败！&amp;#34;, str2) } else { fmt.Printf(&amp;#34;type:%T value:%#v\n&amp;#34;, num2, num2) } } Parse 系列函数 Parse 系列函数用于将字符串转换为指定类型的值，其中包括 ParseBool()、ParseFloat()、ParseInt()、ParseUint()。</description>
    </item>
    
    <item>
      <title>hadoop-hdfs学习</title>
      <link>https://linjinbao.github.io/2019/2019-12-26-hdfs%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-26-hdfs%E5%AD%A6%E4%B9%A0/</guid>
      <description>hadoop-hdfs学习 概念 hdfs是一个分布式的，文件存储系统 ，重要特性如下：
 分块存储 统一的抽象目录树 不支持文件修改  shell操作 hadoop fs -ls /：列出文件
hadoop fs -ls hdfs://hadoop-server01:9000/：列出文件
hadoop fs -mkdir -p /aaa/bbb/cc/dd：创建目录
hadoop fs -moveFromLocal D:\public /aaa/bbb：本地文件移动到hdfs
hadoop fs -moveToLocal /aaa/bbb/ d:\fff：hdfs文件移动到本地
Hadoop fs -appendToFile ./hello.txt /hello.txt：文件追加
hadoop fs -cat /hello.txt：显示文件按内容
hadoop fs -tail /weblog/access_log.1：显示文件末尾
hadoop fs -text /weblog/access_log.1：以字符形式打印文件内容
hadoop fs -chmod 755 /aaa/bbb/public：修改文件权限，和linux一致
hadoop fs -copyFromLocal ./jdk.tar.gz /aaa/：拷贝
hadoop fs -cp /aaa/jdk.tar.gz /bbb/jdk.tar.gz.2：在hdfs上拷贝
hadoop fs -mv /aaa/jdk.tar.gz /：在hdfs上移动</description>
    </item>
    
    <item>
      <title>hive学习01-环境搭建</title>
      <link>https://linjinbao.github.io/2019/2019-12-25-hive%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-25-hive%E5%AD%A6%E4%B9%A0/</guid>
      <description>hive学习01-环境搭建 环境准备：
 jdk 自己手动放置在一个不含空格的目录，并配置好JAVA_HOME hadoop安装包 hadoop-2.7.7 http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz hive 安装包hive-2.1.1 http://archive.apache.org/dist/hive/hive-2.1.1/apache-hive-2.1.1-bin.tar.gz  环境准备玩本人目录如下：
&amp;ndash;D:\hadoop
​ &amp;ndash;hadoop-2.7.7
​ &amp;ndash;jdk1.8.0_171
​ &amp;ndash;apache-hive-2.1.1-bin
hadoop环境搭建 第零步：配置环境变量：HADOOP_HOME=D:\hadoop\hadoop-2.7.7
第一步：修改配置文件：
 core-site.xml  &amp;lt;configuration&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;hdfs://localhost:9000&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/configuration&amp;gt;  hdfs-site.xml  &amp;lt;configuration&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;dfs.namenode.name.dir&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;file:/hadoop/data/dfs/namenode&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;dfs.datanode.data.dir&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;file:/hadoop/data/dfs/datanode&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/configuration&amp;gt;  mapred-site.xml（mapred-site.xml.template修改而来）  &amp;lt;configuration&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/configuration&amp;gt;  yarn-site.xml  &amp;lt;configuration&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property&amp;gt; &amp;lt;name&amp;gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&amp;lt;/name&amp;gt; &amp;lt;value&amp;gt;org.apache.hadoop.mapred.ShuffleHandler&amp;lt;/value&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/configuration&amp;gt;  hadoop-env.</description>
    </item>
    
    <item>
      <title>yum 重建数据库解决报错</title>
      <link>https://linjinbao.github.io/2019/2019-12-24-yum%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-24-yum%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>yum 重建数据库解决报错 [root@www~]# cd /var/lib/rpm # rpmdb所在目录 [root@www rpm]# rm -f __db.* # 清除原rpmdb文件 [root@www rpm]# rpm --rebuilddb # 重建rpm数据库 [root@www rpm]# yum clean all # 清除所有yum的缓存 </description>
    </item>
    
    <item>
      <title>使用Java操作mongdb，redis，rabbitmq</title>
      <link>https://linjinbao.github.io/2019/2019-12-22-java%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-22-java%E6%93%8D%E4%BD%9C/</guid>
      <description>使用Java操作mongdb，redis，rabbitmq Java操作mongodb public static void main(String[] args) { MongoClient mongoClient = new MongoClient(&amp;#34;192.168.220.130&amp;#34;, 27017); MongoDatabase mongoDatabase = mongoClient.getDatabase(&amp;#34;test&amp;#34;); MongoCollection&amp;lt;Document&amp;gt; collection = mongoDatabase.getCollection(&amp;#34;user&amp;#34;); Document document = new Document(&amp;#34;name&amp;#34;,&amp;#34;张三&amp;#34;) .append(&amp;#34;sex&amp;#34;, &amp;#34;男&amp;#34;) .append(&amp;#34;age&amp;#34;, 18); collection.insertOne(document) ; FindIterable findIterable = collection.find(); MongoCursor cursor = findIterable.iterator(); while (cursor.hasNext()) { System.out.println(cursor.next()); } } 需要用到的jar包：mongo-java-driver-3.4.3.jar
Java操作redis public static void main(String[] args) { Jedis jedis = new Jedis(&amp;#34;192.168.220.130&amp;#34;,6379); jedis.set(&amp;#34;username&amp;#34;, &amp;#34;ljbao&amp;#34;); System.out.println(jedis.ping()); System.out.println(jedis.get(&amp;#34;username&amp;#34;)); } 需要用到的jar包：jedis-2.9.0.jar
Java操作rabbitmq public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.</description>
    </item>
    
    <item>
      <title>SpringMVC学习02</title>
      <link>https://linjinbao.github.io/2019/2019-12-09-springmvc%E5%AD%A6%E4%B9%A002/</link>
      <pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-09-springmvc%E5%AD%A6%E4%B9%A002/</guid>
      <description>SpringMVC学习02 获取请求 @RequestParam(&amp;#34;userid&amp;#34;) String userid; //获取请求参数 @RequestHeader(&amp;#34;User-Agent&amp;#34;)String userAgent; //获取请求头 @CookieValue(value = &amp;#34;JSESSIONID&amp;#34;, required = false); //获取Cookie 解决乱码 web.xml
&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;forceEncoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt; &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;gt; 注意：要求字符编码Filter在其他filter之前
数据输出 ** Map
@RequestMapping(&amp;#34;/handle01&amp;#34;) public String handle01(Map map) { System.out.println(&amp;#34;访问了handle01&amp;#34;); map.put(&amp;#34;msg&amp;#34;,&amp;#34;你好&amp;#34;); return &amp;#34;success&amp;#34;; } ** Model
@RequestMapping(&amp;#34;/handle01&amp;#34;) public String handle01(Model model) { System.out.println(&amp;#34;访问了handle01&amp;#34;); model.addAttribute(&amp;#34;msg&amp;#34;, &amp;#34;modelsss&amp;#34;); return &amp;#34;success&amp;#34;; } ** ModelMap
@RequestMapping(&amp;#34;/handle01&amp;#34;) public String handle01(ModelMap modelMap) { System.</description>
    </item>
    
    <item>
      <title>SpringMVC学习01</title>
      <link>https://linjinbao.github.io/2019/2019-12-08-springmvc%E5%AD%A6%E4%B9%A001/</link>
      <pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-08-springmvc%E5%AD%A6%E4%B9%A001/</guid>
      <description>SpringMVC学习01 ant风格url spring官方解释
/** * In a Servlet environment only: the path mapping URIs (e.g. &amp;#34;/myPath.do&amp;#34;). * Ant-style path patterns are also supported (e.g. &amp;#34;/myPath/*.do&amp;#34;). * At the method level, relative paths (e.g. &amp;#34;edit.do&amp;#34;) are supported within * the primary mapping expressed at the type level. Path mapping URIs may * contain placeholders (e.g. &amp;#34;/${connect}&amp;#34;) * &amp;lt;p&amp;gt;&amp;lt;b&amp;gt;Supported at the type level as well as at the method level!&amp;lt;/b&amp;gt; * When used at the type level, all method-level mappings inherit * this primary mapping, narrowing it for a specific handler method.</description>
    </item>
    
    <item>
      <title>docker部署wordpress</title>
      <link>https://linjinbao.github.io/2019/2019-12-07-docker%E9%83%A8%E7%BD%B2wordpress/</link>
      <pubDate>Sat, 07 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-07-docker%E9%83%A8%E7%BD%B2wordpress/</guid>
      <description>docker部署wordpress 环境要求： 1. docker 2. Linux服务器
第一步：准备配置文件 uploads.ini
file_uploads = On memory_limit = 64M upload_max_filesize = 64M post_max_size = 64M max_execution_time = 600 第二步：下载wordpress镜像和mysql镜像
docker pull wordpress docker pull mysql:5.7 第三步：启动mysql服务，启动wordpress服务
docker run -dit -p 3306:3306 --name mysql5.7 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker run -dit -p80:80 --name myblog -v /root/uploads.ini:/usr/local/etc/php/conf.d/uploads.ini wordpress:latest 第四步：配置数据库
docker exec -it mysql:5.7 /bin/bash ##进入mysql容器 mysql -uroot -p123456 ##登录数据库 create database wordpress; ##创建wordpress数据库 之后访问IP名即可看到wordpress程序初始化程序
数据库名：wordpress 用户名：自定义 密码：自己填 数据库主机：本服务器IP 表前缀：默认</description>
    </item>
    
    <item>
      <title>jvm学习02</title>
      <link>https://linjinbao.github.io/2019/2019-12-07-jvm%E5%AD%A6%E4%B9%A002/</link>
      <pubDate>Sat, 07 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-07-jvm%E5%AD%A6%E4%B9%A002/</guid>
      <description>jvm学习02-jdk自带工具使用 jps 解释：虚拟机进程状况工具 参数： -q 只输出lvmid，省略主类的名称 -m 输出虚拟机进程启动的时候传递给朱磊main()函数的参数 -l 输出主类的全名，如果进程执行的是jar包，则输出jar包路径 -v 输出虚拟机进程启动的时候的jvm参数
示例：
C:\Users\linjinbao666\Desktop&amp;gt;jps -v 11776 Bootstrap -Dcatalina.base=C:\Users\linjinbao666\eclipse-workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0 -Dcatalina.home=D:\tomcat\apache-tomcat-7.0.92 -Dwtp.deploy=C:\Users\linjinbao666\eclipse-workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps -Djava.endorsed.dirs=D:\tomcat\apache-tomcat-7.0.92\endorsed -Dfile.encoding=GBK 7280 Jps -Dapplication.home=C:\Program Files\Java\jdk1.8.0_171 -Xms8m 11700 -Dosgi.requiredJavaVersion=1.8 -Dosgi.instance.area.default=@user.home/eclipse-workspace -XX:+UseG1GC -XX:+UseStringDeduplication -Dosgi.requiredJavaVersion=1.8 -Dosgi.dataAreaRequiresExplicitInit=true -Xms256m -Xmx1024m -Declipse.p2.max.threads=10 -Doomph.update.url=http://download.eclipse.org/oomph/updates/milestone/latest -Doomph.redirection.index.redirection=index:/-&amp;gt;http://git.eclipse.org/c/oomph/org.eclipse.oomph.git/plain/setups/ C:\Users\linjinbao666\Desktop&amp;gt; jstat 解释：虚拟机统计信息监视工具 参数： -class 监视类装载，卸载数量，总空间以及装在所消耗的时间 -gc 监视Java堆状况，包括eden区，两个survivor区，老年代，永久代的容量，已用空间，gc时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注java堆各个区域使用到的最大最小空间 -gcutil 监视内容同上，输出关注已使用空间占总空间的百分比 -gccause 同上，额外加上导致上次gc的产生原因 -gcnew 监视新生代gc的状况 -gcnewcapacity -gcold 监视老年代gc状况 -gcoldcapacity -gcpermcapacity监视永久代 -compiler 输出JIT编译器编译过的方法，耗时等信息 -printcompilation 输出已经被JIT编译的方法
示例:
C:\Users\linjinbao666\Desktop&amp;gt;jstat -gc 11776 250 10 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT 5120.</description>
    </item>
    
    <item>
      <title>git分支管理</title>
      <link>https://linjinbao.github.io/2019/2019-12-06-git%E5%88%86%E4%B9%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-06-git%E5%88%86%E4%B9%8B%E7%AE%A1%E7%90%86/</guid>
      <description>git分支管理 基本命令  git branch git branch ：创建分支，名称为 git branch：显示当前分枝，和本地分支 git branch -a：显示所有，包含远程分支 git branch -d dev：删除分支 git branch -vv ：查看本地分支对应的远程分支 git branch -m oldName newName：重命名 git checkout  git checkout * ：切换当前分支
git checkout &amp;ndash; filename：撤销文件的修改，仅限在git add执行之前有效 git checkout &amp;ndash; . ： 多个一起撤销，限制同上
 git merge  git merge * ：该命令将＊＊＊ 分支合并到当前分支
 git文件修改撤销  如果在git commit之前，使用git checkout；如果时在git commit之后，使用git reset</description>
    </item>
    
    <item>
      <title>git分支管理</title>
      <link>https://linjinbao.github.io/2019/2019-12-06-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-06-git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</guid>
      <description>git分支管理 基本命令   git branch git branch *** ：创建分支，名称为*** git branch：显示当前分枝，和本地分支 git branch -a：显示所有，包含远程分支 git branch -d dev：删除分支 git branch -vv ：查看本地分支对应的远程分支 git branch -m oldName newName：重命名
  git checkout
  git checkout *** ：切换当前分支
git checkout &amp;ndash; filename：撤销文件的修改，仅限在git add执行之前有效 git checkout &amp;ndash; . ： 多个一起撤销，限制同上
git merge  git merge *** ：该命令将＊＊＊　分支合并到当前分支
git文件修改撤销  如果在git commit之前，使用git checkout；如果时在git commit之后，使用git reset</description>
    </item>
    
    <item>
      <title>jvmGC日志分析</title>
      <link>https://linjinbao.github.io/2019/2019-12-06-jvmgc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-06-jvmgc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</guid>
      <description>jvmGC日志分析 TestGC.java
public class TestGc { private static final int _1MB = 1024*1024; public static void main(String[] args) { byte[] allocation1, allocation2, allocation3, allocation4,allocation5,allocation6; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[4 * _1MB]; allocation4 = new byte[4 * _1MB]; // allocation5 = new byte[2 * _1MB]; // allocation6 = new byte[1 * _1MB];  } } gc输出
0.083: [GC (Allocation Failure) --[PSYoungGen: 5141K-&amp;gt;5141K(9216K)] 5141K-&amp;gt;5181K(9728K), 0.</description>
    </item>
    
    <item>
      <title>node学习01</title>
      <link>https://linjinbao.github.io/2019/2019-12-06-node%E5%AD%A6%E4%B9%A001/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-06-node%E5%AD%A6%E4%B9%A001/</guid>
      <description>node操作mysql 第一步：引入mysql模块 var mysql = require(&#39;mysql&#39;);第二步：建立连接 var connection = mysql.createConnection({host:&#39;localhost&#39;,user: &#39;root&#39;,password: &#39;Gepoint&#39;,database: &#39;mqtt&#39;});connection.connect();第三步：执行sql操作 var sql = &#39;SELECT * FROM user&#39;;var sql_insert = &amp;quot;insert into user(userid, username, userpass)&amp;quot; +&amp;quot;values(&#39;1151301118&#39;, &#39;ljabo&#39;, &#39;123321&#39;)&amp;quot;;connection.query(sql_insert)var sql_update = &amp;quot;UPDATE USER SET userpass = ? WHERE id = ? &amp;quot;;var mysqlParms = [&#39;gggg3&#39;, &#39;2&#39;] connection.query(sql_update, mysqlParms)connection.query(sql,function (err, result) {if(err){console.log(&#39;[SELECT ERROR] - &#39;, err.</description>
    </item>
    
    <item>
      <title>node学习01</title>
      <link>https://linjinbao.github.io/2019/2019-12-06-node%E6%93%8D%E4%BD%9Cmysql/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-06-node%E6%93%8D%E4%BD%9Cmysql/</guid>
      <description>node操作mysql 第一步：引入mysql模块 var mysql = require(&amp;#39;mysql&amp;#39;); 第二步：建立连接 var connection = mysql.createConnection( { host:&amp;#39;localhost&amp;#39;, user: &amp;#39;root&amp;#39;, password: &amp;#39;Gepoint&amp;#39;, database: &amp;#39;mqtt&amp;#39; }); connection.connect(); 第三步：执行sql操作 var sql = &amp;#39;SELECT * FROM user&amp;#39;; var sql_insert = &amp;#34;insert into user(userid, username, userpass)&amp;#34; + &amp;#34;values(&amp;#39;1151301118&amp;#39;, &amp;#39;ljabo&amp;#39;, &amp;#39;123321&amp;#39;)&amp;#34;; connection.query(sql_insert) var sql_update = &amp;#34;UPDATE USER SET userpass = ? WHERE id = ? &amp;#34;; var mysqlParms = [&amp;#39;gggg3&amp;#39;, &amp;#39;2&amp;#39;] connection.query(sql_update, mysqlParms) connection.query(sql,function (err, result) { if(err){ console.log(&amp;#39;[SELECT ERROR] - &amp;#39;, err.</description>
    </item>
    
    <item>
      <title>Linux学习</title>
      <link>https://linjinbao.github.io/2019/2019-12-05-linux%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%9F%A5%E7%9C%8B/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-05-linux%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%9F%A5%E7%9C%8B/</guid>
      <description>Linux 端口占用查看  ss查看  ss -lntpd | grep :22 示例：
[root@jk-zhengwu03 ~]# ss -lntpd Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port tcp LISTEN 0 128 *:27017 *:* users:((&amp;#34;mongod&amp;#34;,pid=5175,fd=11)) tcp LISTEN 0 128 *:22 *:* users:((&amp;#34;sshd&amp;#34;,pid=1399,fd=3)) tcp LISTEN 0 100 127.0.0.1:25 *:* users:((&amp;#34;master&amp;#34;,pid=2557,fd=13)) tcp LISTEN 0 50 :::8080 :::* users:((&amp;#34;java&amp;#34;,pid=4085,fd=161)) tcp LISTEN 0 128 :::22 :::* users:((&amp;#34;sshd&amp;#34;,pid=1399,fd=4))  netstat  netstat -tnlp \| grep 22 netstat -nultp 示例：
[root@jk-zhengwu03 ~]# netstat -tnlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.</description>
    </item>
    
    <item>
      <title>Linux端口扫描</title>
      <link>https://linjinbao.github.io/2019/2019-12-05-linux%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-05-linux%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</guid>
      <description>2019-12-05-Linux端口扫描 Linux扫描网段主机是否可通  单纯扫描  ##!/bin/sh declare -i I=1 declare -i S=100 while \[ $I -le $S \] ; do IP=&amp;#34;192.168.1.$I&amp;#34; STATE=`ping $IP -c 1 | grep time=0. | awk &amp;#39;{print $8}&amp;#39;` echo -n &amp;#34;$IP&amp;#34; if \[ &amp;#34;$STATE&amp;#34; = &amp;#34;ms&amp;#34; \] ; then echo &amp;#34;yes&amp;#34; else echo &amp;#34;no&amp;#34; fi I+=1 done 扫描并打印  #!/bin/sh  declare -i I=1 declare -i S=100 while [ $I -le $S ] ; do IP=&amp;#34;192.168.1.$I&amp;#34; STATE=`ping $IP -c 1 | grep time=0.</description>
    </item>
    
    <item>
      <title>mysql分布式数据库01</title>
      <link>https://linjinbao.github.io/2019/2019-12-04-mysql%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Wed, 04 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-04-mysql%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>mysql分布式事务01 分布式事务组成  资源管理器： 提供访问事务资源的方法，通常一个数据库就是一个资源管理器 事务管理器： 协调参与全局事务的各个事务。需要和参与全局事务中的所有资源管理器进行通信。 应用程序： 定义事务的边界，指定全局事务中的操作。  提交方式 两段式提交。在第一个阶段，所有参与全局事务的节点都开始准备，告诉事务管理器他们准备提交了；第二阶段，事务管理器告诉资源管理器执行commit或者时rollback，如果任意一个节点显示不能提交，则所有的节点进行回滚。
代码示例：
 MyXid.java  public class MyXid implements Xid{ public int formatId; public byte gtrid[]; public byte bqual[]; public MyXid() { } public MyXid(int formatId, byte gtrid[], byte bqual[]) { this.formatId = formatId; this.gtrid = gtrid; this.bqual = bqual; } @Override public byte[] getBranchQualifier() { return bqual; } @Override public int getFormatId() { return formatId; } @Override public byte[] getGlobalTransactionId() { return gtrid; } }   Demo1.</description>
    </item>
    
    <item>
      <title>java多线程处理数据表格</title>
      <link>https://linjinbao.github.io/2019/2019-12-03-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/</link>
      <pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-03-java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E8%A1%A8%E6%A0%BC/</guid>
      <description>java多线程处理数据表格 问题描述： 现在需要处理一个excel表格，数据量几百条，我使用多线程处理
思路描述： 使用import java.util.concurrent.ExecutorService;和import java.util.concurrent.Executors;类实现
核心代码：
ExecutorService e = Executors.newFixedThreadPool(10); e.submit(new Runnable() { @Override public void run() { Long id = Thread.currentThread().getId(); logger.info(&amp;#34;当前线程：&amp;#34; + id); try { gr(inpath, outpath, prefix1); } catch (Exception e) { logger.error(&amp;#34;----------转化错误，请参照说明文档-------&amp;#34;); e.printStackTrace(); } } }); e.submit(new Runnable() { @Override public void run() { Long id = Thread.currentThread().getId(); logger.info(&amp;#34;当前线程：&amp;#34; + id); try { fr(inpath, outpath, prefix2, prefix3); } catch (IOException e) { logger.error(&amp;#34;----------转化错误，请参照说明文档-------&amp;#34;); e.printStackTrace(); } } }); e.</description>
    </item>
    
    <item>
      <title>Linux命令学习</title>
      <link>https://linjinbao.github.io/2019/2019-12-03-linux%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Tue, 03 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-03-linux%E5%AD%A6%E4%B9%A0/</guid>
      <description>Linux命令学习 更新yum源 cd /ect/yum.repos.d/CentOS-Base.repo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum makecache yum -y update Linux系统监控命令  top命令  top - 14:10:24 up 83 days, 22:45, 1 user, load average: 0.00, 0.03, 0.05 Tasks: 105 total, 1 running, 104 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.0 us, 3.1 sy, 0.0 ni, 96.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 1014856 total, 115416 free, 508424 used, 391016 buff/cache KiB Swap: 0 total, 0 free, 0 used.</description>
    </item>
    
    <item>
      <title>mysql学习07-事务</title>
      <link>https://linjinbao.github.io/2019/2019-12-02-mysql%E5%AD%A6%E4%B9%A007/</link>
      <pubDate>Mon, 02 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-02-mysql%E5%AD%A6%E4%B9%A007/</guid>
      <description>mysql学习07-事务 事务是数据库区别于文件系统的重要特性，来保证数据库的完整性——要么都做修改，要么都不做。 Innodb存储引擎中的事务完全符合ACID的特性。
 原子性 一致性 隔离性 持久性  事务的实现  redo 在innodb存储引擎中，事务日志通过重做日志文件和日志缓冲文件实现。当一个事务开始时，会记录该事务的一个LSN，当事务执行的时候，会往innodb存储引擎的日志缓冲里插入事务日志；当事务提交时候，必须将日志缓冲写入磁盘。也就是在写数据前，需要先写日志。这种方式称作预写日志方式。 innodb通过预写日志的方式保证事务的完整性。 undo 重做日志记录了事务的行为，可以很好的对其进行“重做”。但是事务y有时需要撤销，这时需要undo。  </description>
    </item>
    
    <item>
      <title>mysql 学习06-锁</title>
      <link>https://linjinbao.github.io/2019/2019-12-01-mysql%E5%AD%A6%E4%B9%A006/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-12-01-mysql%E5%AD%A6%E4%B9%A006/</guid>
      <description>mysql 学习06-锁 什么是锁 锁是数据库系统的一个关键特性，锁机制用于管理共享资源的并发访问。InnoDB是行级锁。
SELECT * from information_schema.INNODB_TRX ##啥看事务 SELECT * FROM information_schema.INNODB_LOCKS ##查看锁 show processlist; ##查看线程 show full processlist; show open tables from ***; show status like &amp;#39;%lock%&amp;#39;; ##查看服务器状态 show variables like &amp;#39;%timeout%&amp;#39;; ## SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; ##查看等待锁的事务 innodb_automic_lock_mode参数设置 innodb_automic_lock_mode=1 默认设置，对于能够在插入前确定行数的语句，innodb使用互斥量mutex对内存中的计数器进行累加的操作；对于插入前不能确定行数的语句，执行传统的锁机制，会发生阻塞。 innodb_automic_lock_mode=0 5.1.22版本之前的设置，表锁机制，会发生阻塞 innodb_automic_lock_mode=2 全部执行互斥量方式，性能最高，但是问题在于并发插入的时候，导致增长的值不连续
S锁（共享锁）和X锁（排他锁） lock table user read; ## 锁定读 locl table user write; ## 锁定写 unlock tables; ## 释放锁 当锁定读的时候，其他线程可以读数据，但是不能修改数据；当锁定写的时候，其他线程不能读也不能写。
锁带来的问题  丢失更新 脏读  锁升级 锁升级是指将当前锁的颗粒度降低。举例来说，数据库可以把一个表的1000个行锁升级成一个页锁，或者将页锁升级成表锁。锁升级会带来性能的下降。</description>
    </item>
    
    <item>
      <title>Linux 学习191130</title>
      <link>https://linjinbao.github.io/2019/2019-11-30-linux%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-30-linux%E5%AD%A6%E4%B9%A0/</guid>
      <description>Linux 学习 curl 命令 wget -r -p -np -k -nc -c http://tomcat.apache.org/tomcat-9.0-doc wget -r -p -np -k http://xxx.com/xxx 实时刷新命令 watch -d -n 1 cat ***.log tail -f access.log nginx代理后向服务器发送访问者真实IP   nginx配置server
proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   服务器用代码去除这个值或者使用nginx插件
  tcpdump抓包使用 tcpdump -A -i eth0 -w dump-file1 host 10.117.0.201 </description>
    </item>
    
    <item>
      <title>批处理解决IE浏览器设置问题</title>
      <link>https://linjinbao.github.io/2019/2019-11-29-%E6%89%B9%E5%A4%84%E7%90%86%E8%A7%A3%E5%86%B3ie%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-29-%E6%89%B9%E5%A4%84%E7%90%86%E8%A7%A3%E5%86%B3ie%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98/</guid>
      <description>2019-11-29-批处理解决IE浏览器设置问题 功能集合.bat
@echo off title ★ IEl浏览器设置，请先确保浏览器是IE11 ，否则会有设置无法生效 ★ echo 正在启用IE的 ActiveX控件、JAVA脚本、活动脚本，请稍候... ping 127.0.0.1 -n 2 &amp;gt;nul 2&amp;gt;nul set bl=0 :setreg if &amp;#34;%bl%&amp;#34;==&amp;#34;3&amp;#34; goto ex set regpath=HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\%bl% cls echo 本脚本可快速启用IE的 ActiveX控件、JAVA脚本、活动脚本 echo 正在进行 ZONE%bl% 的设置... :启用“activeX控件”“JAVE小程序脚本”“活动脚本” @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1001&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1004&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1200&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1201&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1400&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1402&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1405&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1609&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;1804&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f @reg add &amp;#34;%regpath%&amp;#34; /v &amp;#34;2300&amp;#34; /d &amp;#34;0&amp;#34; /t REG_DWORD /f set /a bl=%bl%+1 goto setreg :ex cls echo IE的 ActiveX控件、JAVA脚本、活动脚本，设置完成 echo 正在添加受信任站点,关闭弹窗功能.</description>
    </item>
    
    <item>
      <title>openvpn服务搭建</title>
      <link>https://linjinbao.github.io/2019/2019-11-28-openvpn%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-28-openvpn%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</guid>
      <description>openvpn服务搭建 安装openvpn 和easy-rsa（制作ca证书） 方法一：
wget http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm rpm -Uvh epel-release-6-8.noarch.rpm yum install openvpn wget https://github.com/OpenVPN/easy-rsa/archive/master.zip unzip master.zip 方法二：
yum -y install epel-release #epel源 yum -y install openvpn easy-rsa ca证书制作（重点难点）   创建目录，并复制easy-rsa 目录
mkdir -p /etc/openvpn/ cp -a easy-rsa /etc/openvpn/   配置，编辑vars文件，根据自己环境配置
cd /etc/openvpn/easy-rsa/easyrsa3 cp vars.example vars vi vars set_var EASYRSA_REQ_COUNTRY &amp;#34;CN&amp;#34; set_var EASYRSA_REQ_PROVINCE &amp;#34;Henan&amp;#34; set_var EASYRSA_REQ_CITY &amp;#34;Zhengzhou&amp;#34; set_var EASYRSA_REQ_ORG &amp;#34;amrom&amp;#34; set_var EASYRSA_REQ_EMAIL &amp;#34;1576654308@qq.com&amp;#34; set_var EASYRSA_REQ_OU &amp;#34;My OpenVPN&amp;#34;   创建服务端证书及key</description>
    </item>
    
    <item>
      <title>网站申请SSL证书-腾讯云</title>
      <link>https://linjinbao.github.io/2019/2019-11-27-%E7%BD%91%E7%AB%99%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-27-%E7%BD%91%E7%AB%99%E7%94%B3%E8%AF%B7ssl%E8%AF%81%E4%B9%A6/</guid>
      <description>2019-11-27-网站申请SSL证书 网站申请SSL证书   腾讯云文档
  选择证书类型，这里选择免费的
 配置域名验证  这一步是将腾讯云提供的一串文字，放直到服务器web应用内，腾讯云服务器定时去扫描这个域名，如果发现存在文件且匹配，则证明这个域名是你的，目的就是验证身份
最后访问的url
 等待腾讯验证，验证结束如下图   下载文件并上传到nginx服务器（我这里情况比一般复杂，实际申请的网站和域名绑定的不一致，用了nginx反代）  上面两个文件是我们需要的，一个证书，一个私钥
 在nginx中配置  server { ## 监听80端口，避免大量修改接口 listen 80; ##SSL证书配置 listen 443 ssl; ssl_certificate /opt/nginx1.14.2/conf/1_****_bundle.crt; ssl_certificate_key /opt/nginx1.14.2/conf/2_****.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; server_name localhost; }  重启nginx服务器  总结 以前用过openssl，步骤繁琐，复杂，没想到腾讯的这么好用，但是限制很明显，，，，，，承认的浏览器有点少，，，，，，，，，，，</description>
    </item>
    
    <item>
      <title>个人邮箱服务器搭建</title>
      <link>https://linjinbao.github.io/2019/2019-11-26-%E4%B8%AA%E4%BA%BA%E9%82%AE%E7%AE%B1%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-26-%E4%B8%AA%E4%BA%BA%E9%82%AE%E7%AE%B1%E6%90%AD%E5%BB%BA/</guid>
      <description>个人邮箱服务器搭建 参考文档http://doc.ewomail.com/docs/ewomail/webmail_login
搭建环境要求：
1. 系统没有安装nginx,mysql并且相关端口未占用 2. 端口要求： #端口TCP 8000，8010，8020，25，143，993，995，587，110，109，22，80，465 学习的话直接关闭防火墙systemctl stop firewalld
第一步：配置主机名 set-hostname mail.amrom.tk
第二步：拉取源码并安装 yum -y install git cd /root git clone https://gitee.com/laowu5/EwoMail.git cd /root/EwoMail/install 需要输入一个邮箱域名，不需要前缀，列如下面的amrom.tk sh ./start.sh amrom.tk 第三步：配置域名解析 127.0.0.1 mail.amrom.tk smtp.amrom.tk imap.amrom.tk 访问地址 邮箱管理后台：http://IP:8010 （默认账号admin，密码ewomail123）
web邮件系统：http://IP:8000
更进一步 到目前位置，邮件服务器只能主动发出邮件，并且有可能被拒收，因为上面的域名amrom.tk只有本机认识，如果需要能够收到邮件，则需要购买这个域名，有钱就去万网买，没钱就tk域名走起</description>
    </item>
    
    <item>
      <title>nginx代理出来的页面使用IE无法加载png问题</title>
      <link>https://linjinbao.github.io/2019/2019-11-25-nginx%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-25-nginx%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/</guid>
      <description>nginx代理出来的页面使用IE无法加载png问题 问题描述： 使用nginx对站点进行反代，其他都正常，但是有个png图片无法加载。排查了情况如下： 1. 其他浏览器正常 2. IE在内网正常，访问原始地址 3. IE在外网异常，访问nginx代理后地址
问题分析： 检查F12，发现图片状态码200，已经加载出来，但是没有渲染出来，推测是由于安全策略问题；比对内网header和外网访问header，发现区别在外网多了个X-Content-Type-Options: nosniff，估计问题在这。
问题解决： 在nginx代理中，去掉add_header X-Content-Type-Options nosniff;配置项 问题解决
总结 X-Content-Type-Options nosniff是什么？
如果服务器发送响应头 &amp;ldquo;X-Content-Type-Options: nosniff&amp;rdquo;，则 script 和 styleSheet 元素会拒绝包含错误的 MIME 类型的响应。这是一种安全功能，有助于防止基于 MIME 类型混淆的攻击。
如果通过 styleSheet 参考检索到的响应中接收到 &amp;ldquo;nosniff&amp;rdquo; 指令，则 Windows Internet Explorer 不会加载“stylesheet”文件，除非 MIME 类型匹配 &amp;ldquo;text/css&amp;rdquo;。
如果通过 script 参考检索到的响应中接收到 &amp;ldquo;nosniff&amp;rdquo; 指令，则 Internet Explorer 不会加载“script”文件，除非 MIME 类型匹配以下值之一：
&amp;#34;application/ecmascript&amp;#34; &amp;#34;application/javascript&amp;#34; &amp;#34;application/x-javascript&amp;#34; &amp;#34;text/ecmascript&amp;#34; &amp;#34;text/javascript&amp;#34; &amp;#34;text/jscript&amp;#34; &amp;#34;text/x-javascript&amp;#34; &amp;#34;text/vbs&amp;#34; &amp;#34;text/vbscript&amp;#34; 解决方案： 1. 使用image/png明确页面内容，同时启用X-Content-Type-Options: nosniff，禁用浏览器类型猜测行为 2. 禁用X-Content-Type-Options: nosniff，允许浏览器猜测行为</description>
    </item>
    
    <item>
      <title>linux find 按文件时间查询</title>
      <link>https://linjinbao.github.io/2019/2019-11-23-linux-find%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-23-linux-find%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E6%9F%A5%E8%AF%A2/</guid>
      <description>需求:删除 /home/ljbao/myback/files 目录下7分钟之前生成的gz类型的文件 find /home/ljbao/myback/files -mtime +7 -name &amp;#34;*.gz&amp;#34; -exec rm {} \; //时间条件
-amin n: 查找n分钟以前被访问过的所有文件。 -atime n: 查找n天以前被访问过的所有文件。 -cmin n: 查找n分钟以前文件状态被修改过的所有文件。 -ctime n: 查找n天以前文件状态被修改过的所有文件。 -mmin n: 查找n分钟以前文件内容被修改过的所有文件。 -mtime n: 查找n天以前文件内容被修改过的所有文件。 </description>
    </item>
    
    <item>
      <title>mysql 定时备份</title>
      <link>https://linjinbao.github.io/2019/2019-11-23-mysql%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/</link>
      <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-23-mysql%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD/</guid>
      <description>mysql 定时备份 第一步：写备份脚本 backup_full.sh
#!/bin/bash BACKUP_ROOT=/home/ljbao/myback BACKUP_FILEDIR=$BACKUP_ROOT/files BACKUP_LOGDIR=$BACKUP_ROOT/logs #当前日期 DATE=$(date +%Y%m%d) DATABASES=$(mysql -uroot -p*** -e &amp;#34;show databases&amp;#34; | grep -Ev &amp;#34;Database|sys|information_schema&amp;#34;) echo $DATABASES #循环数据库进行备份 for db in $DATABASES do echo echo ----------$BACKUP_FILEDIR/${db}_$DATE.sql.gz BEGIN---------- mysqldump -uroot -p*** --default-character-set=utf8 -q --lock-all-tables --flush-logs -E -R --triggers -B ${db} | gzip &amp;gt; $BACKUP_FILEDIR/${db}_$DATE.sql.gz echo ----------$BACKUP_FILEDIR/${db}_$DATE.sql.gz COMPLETE---------- echo done echo &amp;#34;back complete&amp;#34; 第二步：注册定时任务
[root@localhost myback]# crontab -l -uroot ## 每天3点 00 3 * * * sh /home/ljbao/myback/backup_full.</description>
    </item>
    
    <item>
      <title>mysql学习04</title>
      <link>https://linjinbao.github.io/2019/2019-11-23-mysql%E5%AD%A6%E4%B9%A004/</link>
      <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-23-mysql%E5%AD%A6%E4%B9%A004/</guid>
      <description>mysql学习04-表   innodb_file_per_table ## 每张表数据可以单独放到一个表空间
show variables like &amp;#39;innodb_file_per_table&amp;#39;;   约束 约束是为了保证数据库中的数据完整性
  实体完整性
保证表中有一个主键。
  域完整性
保证数据的值满足特定的条件。
参照完整性
保证两张表之间的关系。
  InnoDB的约束：
Primary Key Unique Key Forign Key Default NOT NULL 示例：
create table u (id int , name varchar(20) , primary key (id) , unique key (name)); infomation_schema库的表TABLE_CONSTRAINTS存放了数据库所有约束
mysql&amp;gt; select * from TABLE_CONSTRAINTS; +--------------------+-------------------+-----------------+--------------+---------------------------+-----------------+ | CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE | +--------------------+-------------------+-----------------+--------------+---------------------------+-----------------+ | def | lin | PRIMARY | lin | u | PRIMARY KEY | | def | lin | name | lin | u | UNIQUE | | def | lin | PRIMARY | lin | user1 | PRIMARY KEY | | def | mysql | PRIMARY | mysql | columns_priv | PRIMARY KEY | | def | mysql | PRIMARY | mysql | db | PRIMARY KEY | | def | mysql | PRIMARY | mysql | engine_cost | PRIMARY KEY | | def | mysql | PRIMARY | mysql | event | PRIMARY KEY | | def | mysql | PRIMARY | mysql | func | PRIMARY KEY | | def | mysql | PRIMARY | mysql | gtid_executed | PRIMARY KEY | | def | mysql | PRIMARY | mysql | help_category | PRIMARY KEY | | def | mysql | name | mysql | help_category | UNIQUE | | def | mysql | PRIMARY | mysql | help_keyword | PRIMARY KEY | | def | mysql | name | mysql | help_keyword | UNIQUE | | def | mysql | PRIMARY | mysql | help_relation | PRIMARY KEY | | def | mysql | PRIMARY | mysql | help_topic | PRIMARY KEY | | def | mysql | name | mysql | help_topic | UNIQUE | | def | mysql | PRIMARY | mysql | innodb_index_stats | PRIMARY KEY | | def | mysql | PRIMARY | mysql | innodb_table_stats | PRIMARY KEY | | def | mysql | PRIMARY | mysql | ndb_binlog_index | PRIMARY KEY | | def | mysql | PRIMARY | mysql | plugin | PRIMARY KEY | | def | mysql | PRIMARY | mysql | proc | PRIMARY KEY | | def | mysql | PRIMARY | mysql | procs_priv | PRIMARY KEY | | def | mysql | PRIMARY | mysql | proxies_priv | PRIMARY KEY | | def | mysql | PRIMARY | mysql | server_cost | PRIMARY KEY | | def | mysql | PRIMARY | mysql | servers | PRIMARY KEY | | def | mysql | PRIMARY | mysql | slave_master_info | PRIMARY KEY | | def | mysql | PRIMARY | mysql | slave_relay_log_info | PRIMARY KEY | | def | mysql | PRIMARY | mysql | slave_worker_info | PRIMARY KEY | | def | mysql | PRIMARY | mysql | tables_priv | PRIMARY KEY | | def | mysql | PRIMARY | mysql | time_zone | PRIMARY KEY | | def | mysql | PRIMARY | mysql | time_zone_leap_second | PRIMARY KEY | | def | mysql | PRIMARY | mysql | time_zone_name | PRIMARY KEY | | def | mysql | PRIMARY | mysql | time_zone_transition | PRIMARY KEY | | def | mysql | PRIMARY | mysql | time_zone_transition_type | PRIMARY KEY | | def | mysql | PRIMARY | mysql | user | PRIMARY KEY | | def | sys | PRIMARY | sys | sys_config | PRIMARY KEY | +--------------------+-------------------+-----------------+--------------+---------------------------+-----------------+ 36 rows in set (0.</description>
    </item>
    
    <item>
      <title>mysql 关闭主从</title>
      <link>https://linjinbao.github.io/2019/2019-11-22-mysql%E5%85%B3%E9%97%AD%E4%B8%BB%E4%BB%8E/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-22-mysql%E5%85%B3%E9%97%AD%E4%B8%BB%E4%BB%8E/</guid>
      <description>2019-11-22-mysql 关闭主从 mysql 关闭主从 执行STOP SLAVE语句 使用SHOW STATUS检查slave_open_temp_tables变量的值 如果值为0，使用mysqladmin shutdown命令关闭从服务器 如果值不为0，用START SLAVE重启从服务器线程 slave_open_temp_tables值显示，当前slave创建了多少临时表，注意由client显示创建的 即便是这样，在使用临时表的场景下，如果服务器宕机，将遇到不可预知的问题。 所以比较保险的做法是，创建实体表，虽然会由于分配的文件刷新到磁盘。
mysql&amp;gt; show status like &amp;#39;%slave%&amp;#39;; +------------------------+-------+ | Variable_name | Value | +------------------------+-------+ | Com_show_slave_hosts | 0 | | Com_show_slave_status | 0 | | Com_slave_start | 0 | | Com_slave_stop | 0 | | Slave_open_temp_tables | 0 | +----------------------- mysql删除主从 进入mysql
mysql&amp;gt; slave stop; mysql&amp;gt;reset slave; mysql&amp;gt;change master to master_user=&amp;#39;&amp;#39;, master_host=&amp;#39;&amp;#39;, master_password=&amp;#39;&amp;#39;;结果报错如下： ERROR 1210 (HY000): Incorrect arguments to MASTER_HOST 解决办法如下： mysql&amp;gt;change master to master_host=&amp;#39; &amp;#39;; 即可成功删除同步用户信息。 注意：上面的命令报错的原因，为master_host=&amp;rsquo; &#39; 里面必须有内容，即使为空，也应该用空格代替，而不能什么都不写。</description>
    </item>
    
    <item>
      <title>mysql学习03</title>
      <link>https://linjinbao.github.io/2019/2019-11-22-mysql%E5%AD%A6%E4%B9%A003/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-22-mysql%E5%AD%A6%E4%B9%A003/</guid>
      <description>第3章-mysql系统文件   查询慢查询设置
```sql
show variables like &amp;lsquo;%long%&#39;;
show variables like &amp;lsquo;log_slow_queries&amp;rsquo;;
set long_query_time=1; #1秒
  show variables like &amp;lsquo;slow_query_log&amp;rsquo;; # 日志是否开启 show variables like &amp;lsquo;slow_query_log_file&amp;rsquo;; # 日志位置
show variables like &amp;lsquo;log_queries_not_using_indexes&amp;rsquo;; # 以索引判断
慢查询的sql记录存放在`mysql.slow_slow`中 2. 二进制日志 ```sql show variables like &amp;#39;datadir&amp;#39;; show variables like &amp;#39;max_binlog_size&amp;#39;; //单个二进制文件的最大值 show variables like &amp;#39;binlog_cache_size&amp;#39;; mysql&amp;gt; show variables like &amp;#39;binlog_format&amp;#39;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | binlog_format | ROW | +---------------+-------+ 1 row in set ## STATEMENT表示记录sql语句 ## ROW表示记录行数据 ## MIXED 表示兼顾以上2种  pid文件  mysql&amp;gt; show variables like &amp;#39;pid_file&amp;#39;; +---------------+------------------------------------------------------------------------+ | Variable_name | Value | +---------------+------------------------------------------------------------------------+ | pid_file | D:\epoint_mysql_5.</description>
    </item>
    
    <item>
      <title>Mysql学习系列02</title>
      <link>https://linjinbao.github.io/2019/2019-11-22-mysql%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9702/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-22-mysql%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9702/</guid>
      <description>2019-11-22-Mysql学习系列02 mysql 报错 错误代码： 1786 Statement violates GTID consistency: CREATE TABLE ... SELECT. 错误原因 这是因为在5.6及以上的版本内，开启了 enforce_gtid_consistency=true 功能导致的，MySQL官方解释说当启用 enforce_gtid_consistency 功能的时候，MySQL只允许能够保障事务安全，并且能够被日志记录的SQL语句被执行，像create table … select 和 create temporarytable语句，以及同时更新事务表和非事务表的SQL语句或事务都不允许执行。
解决 修改 ：SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = off;</description>
    </item>
    
    <item>
      <title>mysql配置记录sql</title>
      <link>https://linjinbao.github.io/2019/2019-11-22-mysql%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95sql/</link>
      <pubDate>Fri, 22 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-22-mysql%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95sql/</guid>
      <description>2019-11-22-mysql配置记录sql 1.修改配置文件，my.cnf
#vi /etc/my.cnf log =/mysql/mysqls.log #慢查询语句 ,time 单位是秒 log-slow-queries = /mysql/slowquery.log long_query_time = 1  查看正在执行的SQL语句，用 processlist，缺点是，时时变化，不易观察到需要的SQL 。  mysql&amp;gt; use information_schema; mysql&amp;gt; select * from PROCESSLIST where info is not null; 3.使用 global general_log 参数，方便随时查看
默认也是OFF，使用时候，最好，先查看 用 show global variables like &amp;lsquo;%general%&#39;;
可以看到，log文件的位置，。
SET GLOBAL general_log = &amp;#39;ON&amp;#39;; //需要root权限。 设置ON 之后，就可以查看log文件，数据库所有操作都会记录。
也可以输出到系统表，需要SET GLOBAL log_output = &amp;lsquo;TABLE&amp;rsquo;; 然后，查看 SELECT * from mysql.general_log ORDER BY event_time DESC ；</description>
    </item>
    
    <item>
      <title>Linux用户，用户组，密码，文件权限</title>
      <link>https://linjinbao.github.io/2019/2019-11-20-linux/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-20-linux/</guid>
      <description>Linux用户，用户组，密码，文件权限 用户 相关命令 useradd userdel usermod /etc/passwd文件内容 用户名:密码:UID:GID:用户信息:HOME目录路径:用户shell
root❌0:0:root:/root:/bin/bash
/etc/shadow文件内容 用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段
postfix:!!:18220:::::: ljbao:$6$1QXKHgXD$66Aj/Qyo3QGGxmKAMH9cQfJs61KXieXLurSvdxHWZtIY2hT4HeXrjX6LtfVGEmhYqAV/9KLalvDTSxFQt03i11:18220:0:99999:7::: ljbao2:!!:18220:0:99999:7::: ljbao3:$6$lnlH0Lv5$zyh1jXS5Me4oT8/tX7Ae3fAyVOmsFuQReXLcFaFHcTVGBs7ZExo1idZzhh2pkTxpznPOZcLMv6RqdGByWIv.00:18220:0:99999:7::: 改变用户所属组 usermod -a -G groupA user 用户可以属于多个组，切换用户组命令newgrp
用户组 相关命令 groupadd -g 8888 groupname groupmod groupdel /etc/group文件内容 组名:口令:组标识号:组内用户列表
root❌0:ljbao ljbao❌8888:ljbao3,ljbao2 文件权限 相关命令 chmod：改变文件权限 chown：改变文件属主 chown ljbao2:ljbao testchown/ </description>
    </item>
    
    <item>
      <title>Mysql学习系列01</title>
      <link>https://linjinbao.github.io/2019/2019-11-20-mysql%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9701/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-20-mysql%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%9701/</guid>
      <description>mysql4种事务隔离级别  Read Uncommitted(读取未提交内容)  解释： (1)所有事务都可以看到其他未提交事务的执行结果 (2)本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少 (3)该级别引发的问题是——脏读(Dirty Read)：读取到了未提交的数据
 Read Committed(读取提交内容)  解释： (1)这是大多数数据库系统的默认隔离级别（但不是MySQL默认的） (2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变 (3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。
 Repeatable Read(可重读) 解释： (1)这是MySQL的默认事务隔离级别 (2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行 (3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行 (4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题 Serializable(可串行化)序列化 解释： (1)这是最高的隔离级别 (2)它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之,它是在每个读的数据行上加上共享锁。 (3)在这个级别，可能导致大量的超时现象和锁竞争  设置命令：
mysql&amp;gt; set @@tx_isolation=&amp;#39;Read-Uncommitted&amp;#39;; Query OK, 0 rows affected mysql&amp;gt; select @ @tx_isolation; +----------------+ | @@tx_isolation | +----------------+ | READ-COMMITTED | +----------------+ 1 row in set </description>
    </item>
    
    <item>
      <title>MySQL 分库分表-ShardingSphere使用</title>
      <link>https://linjinbao.github.io/2019/2019-11-17-shardingsphere/</link>
      <pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-17-shardingsphere/</guid>
      <description>MySQL 分库分表-ShardingSphere使用 分库和分表的实现-java工程版  依赖项  &amp;lt;dependencies&amp;gt; &amp;lt;!-- 主要 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;sharding-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.0-RC2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-dbcp&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-dbcp&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.41&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;netty&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.7.0.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;  示例代码  public class ShardingSphereDemo { @Test public void test01() throws SQLException { // 配置真实数据源  Map&amp;lt;String, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;String, DataSource&amp;gt;(); // 配置第一个数据源  BasicDataSource dataSource1 = new BasicDataSource(); dataSource1.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource1.setUrl(&amp;#34;jdbc:mysql://localhost:3306/test&amp;#34;); dataSource1.</description>
    </item>
    
    <item>
      <title>Linux流量检测工具-vnstat使用</title>
      <link>https://linjinbao.github.io/2019/2019-11-16-linux%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7-vnstat%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 16 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-16-linux%E6%B5%81%E9%87%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7-vnstat%E4%BD%BF%E7%94%A8/</guid>
      <description>2019-11-16-Linux流量检测工具-vnstat使用 安装 yum install epel-release -y &amp;amp;&amp;amp; yum install -y vnstat 为指定网卡创建监控数据库 vnstat -u -i eth0 #网卡名，使用 ip a查看 流量查看命令 vnstat -d #每日统计 vnstat -m #每月统计 实时监控 vnstat -l -i eth0 Monitoring eth0... (press CTRL-C to stop) rx: 4 kbit/s 7 p/s tx: 58 kbit/s 4 p/s^C eth0 / traffic statistics rx | tx --------------------------------------+------------------ bytes 13.55 MiB | 13.96 MiB --------------------------------------+------------------ max 7.88 Mbit/s | 9.07 Mbit/s average 740.06 kbit/s | 762.</description>
    </item>
    
    <item>
      <title>Jenkins持续集成工具学习02</title>
      <link>https://linjinbao.github.io/2019/2019-11-15-jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A002/</link>
      <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-15-jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A002/</guid>
      <description>2019-11-15-Jenkins持续集成工具学习02 安装教程见上一节 jenkins持续集成工具学习01
使用-重点 项目的完整发布过程如下：
拉取源码-&amp;gt;maven编译-&amp;gt;部署/推送部署
  安装git
yum install git   安装maven
yum install maven   安装maven Integration插件
在Jenkins插件管理里面安装
  全局配置  jdk路径配置 mavnen路径配置 git配置  获取源码-编译源码-发布源码 新建maven工程，填入关键位置： 1. git源码地址：https://github.com/linjinbao666/mqtt.git 注意源码目录结构：
src main DeviceManage.iml pom.xml 即符合maven编译规则
 maven构建参数：clean package 加上构建后shell脚本，此处部署在本地，如果是要使用另一台节点部署，则需要用到ssh deplay插件，原理一致  \cp -rf /var/lib/jenkins/workspace/demo01/target/*.war /root/tomcat7.0/webapps/mqtt.war &amp;amp;&amp;amp; /root/tomcat7.0/bin/startup.sh 注意：权限问题
cp: failed to access ‘/root/tomcat7.0/webapps/mqtt.war’: Permission denied Build step &amp;#39;Execute shell&amp;#39; marked build as failure 解决方法：设置Jenkins以root用户运行</description>
    </item>
    
    <item>
      <title>Spring事务</title>
      <link>https://linjinbao.github.io/2019/2019-11-14-spring%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-14-spring%E4%BA%8B%E5%8A%A1/</guid>
      <description>Spring事务 JdbcTemplate Spring 提供的JDBC模板 1. tx.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&amp;quot;&amp;gt; &amp;lt;bean id=&amp;quot;datasource&amp;quot; class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;Gepoint&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/mqtt&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;initialPoolSize&amp;quot; value=&amp;quot;10&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;maxPoolSize&amp;quot; value=&amp;quot;100&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;minPoolSize&amp;quot; value=&amp;quot;10&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;maxIdleTime&amp;quot; value=&amp;quot;30&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt;   MyTx.java
public class MyTx { ApplicationContext context = new ClassPathXmlApplicationContext(&amp;#34;tx.xml&amp;#34;); @Test public void test01() throws SQLException { DataSource dataSource = context.getBean(&amp;#34;datasource&amp;#34;,ComboPooledDataSource.class); JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); String sql = &amp;#34;select * from user&amp;#34;; RowMapper&amp;lt;User&amp;gt; rowMapper = new BeanPropertyRowMapper&amp;lt;User&amp;gt;(User.</description>
    </item>
    
    <item>
      <title>ftp服务器搭建</title>
      <link>https://linjinbao.github.io/2019/2019-11-13-ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 13 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-13-ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</guid>
      <description>ftp服务器搭建  安装软件  yum install -y vsftpd  配置  vi vsftpd.conf
anonymous_enable=NO #不允许匿名用户登陆 local_enable=YES #vsftpd所在系统的用户可以登录vsftpd write_enable=YES #允许使用任何可以修改文件系统的FTP的指令 local_umask=002 #匿名用户新增文件的umask数值 anon_upload_enable=NO #匿名用户不可以上传文件 anon_mkdir_write_enable=NO #匿名用户不可以修改文件 xferlog_enable=YES #启用一个日志文件，用于详细记录上传和下载。 use_localtime=YES #使用本地时间而不是GMT vsftpd_log_file=/var/log/vsftpd.log #vsftpd日志存放位置 dual_log_enable=YES #用户登陆日志 connect_from_port_20=YES #开启20端口 xferlog_file=/var/log/xferlog #记录上传下载文件的日志 xferlog_std_format=YES #记录日志使用标准格式 idle_session_timeout=600 #登陆之后超时时间60秒，登陆之后，一分钟不操作，就会断开连接。 chroot_local_user=YES #用于指定用户列表文件中的用户,是否允许切换到上级目录 listen=YES #开启监听 pam_service_name=vsftpd.vu #验证文件的名字 userlist_enable=YES #允许由userlist_file指定文件中的用户登录FTP服务器 tcp_wrappers=YES #支持tcp_wrappers,限制访问(/etc/hosts.allow,/etc/hosts.deny) guest_enable=YES #起用虚拟用户 guest_username=guest #虚拟用户名 #user_config_dir=/etc/vsftpd/vsftpuser #虚拟用户配置文件路径 local_root= /opt/tomcat/logs #自定义ftp上传路径（注意文件夹权限）,给开发下载日志看 pasv_min_port=35000 pasv_max_port=45000 pasv_enable=YES pasv_promiscuous=YES anon_other_write_enable=YES 添加ftp账户 useradd -d /home/ftpUser/ -g epointgroup -s /sbin/nologin hqa passwd ftpUser </description>
    </item>
    
    <item>
      <title>Java定时任务</title>
      <link>https://linjinbao.github.io/2019/2019-11-12-java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%86%99%E6%B3%95/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-12-java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%86%99%E6%B3%95/</guid>
      <description>Java定时任务的几种写法 前言：cron表达式书写： cron = &amp;quot;* * * * * *&amp;quot; {秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)} 每个字段允许值： 秒 0-59 , - / 分 0-59 , - / 小时 0-23 , - / 日期 1-31 , - ? / L W C 月份 1-12 或者 JAN-DEC , - / 星期 1-7 或者 SUN-SAT , - ? / L C # 年 留空, 1970-2099 , - * / 符号的意义：
  表示所有值；</description>
    </item>
    
    <item>
      <title>面向切面编程SpringAOP</title>
      <link>https://linjinbao.github.io/2019/2019-11-12-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8Bspring-aop/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-12-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8Bspring-aop/</guid>
      <description>面向切面编程SpringAOP  注解方式实现aop，xml配置  名称空间xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot; &amp;lt;context:component-scan base-package=&amp;quot;tk.amrom&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt; &amp;lt;aop:aspectj-autoproxy&amp;gt; &amp;lt;/aop:aspectj-autoproxy&amp;gt;   LogUtil.java
```java
  @Aspect @Component public class LogUtil {
@Before(value = &amp;#34;execution(public int tk.amrom.impls.MyMathCaluctor.*(*, int))&amp;#34;) public static void logStart() { System.out.println(&amp;#34;目标方法执行之前执行1。。。。。。&amp;#34;); } @After(value = &amp;#34;execution(public int tk.amrom.impls.MyMathCaluctor.add(int, int)) | &amp;#34; + &amp;#34;execution(public int tk.amrom.impls.MyMathCaluctor.sub(int, int))&amp;#34;) public static void logAfter() { System.out.println(&amp;#34;目标方法执行之后执行2。。。。。。。&amp;#34;); } }
3. TestAOP.java ```java public class TestAOP { ApplicationContext context = new ClassPathXmlApplicationContext(&amp;#34;aop.xml&amp;#34;); @Test public void test01() { Calcultor calcultor = context.</description>
    </item>
    
    <item>
      <title>Jenkins持续集成工具学习01</title>
      <link>https://linjinbao.github.io/2019/2019-11-11-jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A001/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-11-jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A001/</guid>
      <description>2019-11-11-Jenkins持续集成工具学习01 Jenkins持续集成工具学习01  安装Jenkins并启动  docker安装：
docker pull jenkins docker run \ -u root \ --rm \ -d \ -p 8080:8080 \ -p 50000:50000 \ -v jenkins-data:/var/jenkins_home \ -v /var/run/docker.sock:/var/run/docker.sock \ jenkinsci yum安装：
sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key sudo yum install jenkins  访问浏览器IP:8080进行系统配置  使用-重点 </description>
    </item>
    
    <item>
      <title>简单操作excel apache POI使用</title>
      <link>https://linjinbao.github.io/2019/2019-11-11-%E4%BD%BF%E7%94%A8apache-poi%E6%93%8D%E4%BD%9Cexcel/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-11-%E4%BD%BF%E7%94%A8apache-poi%E6%93%8D%E4%BD%9Cexcel/</guid>
      <description>使用apace POI操作excel   pom依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.poi&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;poi&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.8&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   部分java 代码
//部分代码 FileSystemView fsv = FileSystemView.getFileSystemView(); String desktop = fsv.getHomeDirectory().getPath(); String filePath = desktop + &amp;#34;/在线申报地址.xls&amp;#34;; FileInputStream fileInputStream = new FileInputStream(filePath); BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); POIFSFileSystem fileSystem = new POIFSFileSystem(bufferedInputStream); HSSFWorkbook workbook = new HSSFWorkbook(fileSystem); HSSFSheet sheet = workbook.getSheet(&amp;#34;法人&amp;#34;); int lastRowIndex = sheet.getLastRowNum(); for (int i=0; i&amp;lt;lastRowIndex; i++){ HSSFRow row = sheet.getRow(i); if (row == null) { break; } String cellValue = row.</description>
    </item>
    
    <item>
      <title>spring xml使用bean加载数据库连接池</title>
      <link>https://linjinbao.github.io/2019/2019-11-10-spring-xml%E4%BD%BF%E7%94%A8bean%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-10-spring-xml%E4%BD%BF%E7%94%A8bean%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>2019-11-10-spring xml使用bean加载数据库连接池 spring xml使用bean管理数据库连接池 ioc2.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt; &amp;lt;bean id=&amp;quot;datasource&amp;quot; class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;***&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/mqtt&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;com.mysql.jdbc.Driver&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; Test.java
public static void main(String[] args) throws BeansException, SQLException { String fileName = &amp;#34;ioc2.xml&amp;#34;; ApplicationContext context = new ClassPathXmlApplicationContext(fileName); DataSource datasource = (DataSource) context.getBean(&amp;#34;datasource&amp;#34;); // System.out.println(datasource.getConnection());  Connection connection = datasource.getConnection(); Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(&amp;#34;select * from user&amp;#34;); while (resultSet.</description>
    </item>
    
    <item>
      <title>使用svn&#43;docker搭建持续集成环境</title>
      <link>https://linjinbao.github.io/2019/2019-11-09-%E4%BD%BF%E7%94%A8svn-docker%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sat, 09 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-09-%E4%BD%BF%E7%94%A8svn-docker%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</guid>
      <description>使用svn+docker搭建持续集成环境 功能描述： 通过使用svn+docker部署一套自动打包系统，使得项目的打包部署更加简单，只需要做一步操作： 在本地svn上面执行commit操作即可，svn服务器端收到推送后，会利用post-commit钩子将新的项目内容同步到目标路径，同时执行docker打包脚本，被docker部署脚本
准备工具  svn服务端 docker和tomcat基础镜像  实现逻辑  使用svn进行项目更新包的同步 svn hooks完成更新包和tomcat内容的同步 自动化脚本由post-commit调用；完成镜像版本的更新、镜像启动等操作  第一步：安装svn服务端，并且在本地checkout出一份，同时在服务器找个文件夹checkout一份 这一步比较简单，可以看我另一篇博客学习，地址如下：Linux SVN服务端搭建
第二步：配置svn hooks实现自动同步，将版本库中文件自动checkout到docker待打包目录 post-commit文件内容示例如下：
echo &amp;#34;#####开始提交 #####&amp;#34; &amp;gt;&amp;gt; /tmp/svn.log #svn日志 echo &amp;#34;提交时间为：&amp;#34; + `date` &amp;gt;&amp;gt;/tmp/svn.log echo &amp;#34;提交人：&amp;#34; + `whoami` &amp;gt;&amp;gt;/tmp/svn.log /usr/bin/svn update /opt/tomcat/webapps/lin --username *** --password *** --no-auth-cache # 执行docker脚本 sudo sh /opt/tomcat/webapps/lin/docker.sh #调用docker.sh脚本，完成镜像包的制作，容器的制作启动等操作 第三步： 编写docker.sh脚本 docker.sh示例： 由于虚拟机空间有限，镜像包的制作逻辑没有遵循版本号递增的规则，此处每次进行重新构建的操作，如果是服务器环境，可以选择利用版本号做区分，或者和我的注释一样，使用时间戳进行标记
#!/bin/sh # 版本号 #version=`date +%s` #version=`docker images | grep linjinbao666/svntest | awk &amp;#39;{print $2+1}&amp;#39; | awk &amp;#39;{print $1+1}&amp;#39;` #version=`docker images | grep linjinbao666/svntest|head -n -1 | awk &amp;#39;{print $2+1}&amp;#39;` cd /opt/tomcat/webapps/lin systemctl restart docker &amp;gt;&amp;gt; /tmp/docker.</description>
    </item>
    
    <item>
      <title>jvm指令学习</title>
      <link>https://linjinbao.github.io/2019/2019-11-08-jvm%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 08 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-08-jvm%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</guid>
      <description>jvm 指令学习 编写源代码 Hello.java
public class Hello{ public static void main(String[] args){ System.out.println(&amp;#34;Hello!&amp;#34;); } } 编译 javac Hello.java 生成Hello.class
反编译 javap -v -verbose Hello.class &amp;gt; a.txt
a.txt
Classfile /E:/testcode/Hello.class Last modified 2019-11-8; size 410 bytes MD5 checksum 9c850402f9e9212c88f8d34072cfc80b Compiled from &amp;#34;Hello.java&amp;#34; public class Hello minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #6.#15 // java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello!</description>
    </item>
    
    <item>
      <title>Linux SVN服务端搭建</title>
      <link>https://linjinbao.github.io/2019/2019-11-08-svn%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Fri, 08 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-08-svn%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</guid>
      <description>2019-11-08-SVN仓库搭建 SVN仓库服务端搭建 svn功能强大，主要用在以下方面：1. 版本控制；2. 内容同步；3.文件备份
配置步骤 第一步：安装 yum install subversion
第二步：初始化服务
cd /home mkdir svn #创建svn软件工作目录 svnadmin create /home/svn #创建并启动svn服务 [root@192 home]# ls svn conf db format hooks locks README.txt 第三步：配置svn关键参数 1. conf/svnserve.conf 配置svn服务
#去除下面的5个注释 anon-access = read #匿名用户权限 auth-access = write #授权用户权限 password-db = passwd #指定密码文件 authz-db = authz #注定权限文件 realm = /home/svn # 认证空间名，指定版本库所在目录   conf/passwd 配置密码文件
```code
[root@192 conf]# cat passwd
This file is an example password file for svnserve.</description>
    </item>
    
    <item>
      <title>使用工厂方法创建管理bean</title>
      <link>https://linjinbao.github.io/2019/2019-11-08-%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%AE%A1%E7%90%86bean/</link>
      <pubDate>Fri, 08 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-08-%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%AE%A1%E7%90%86bean/</guid>
      <description>使用工厂方法创建管理bean 第一部分： 静态工厂   工厂类写法：
```java
  public class AirPlaneStaticFactory {
/** * 静态工厂 * @param name * @return */ public static Airplane getAirPlane(String name) { Airplane airplane = new Airplane(); airplane.setFjs(&amp;#34;副驾驶&amp;#34;); airplane.setName(name); airplane.setNum(1001001); return airplane; } }
2. xml配置注册bean ```xml &amp;lt;!-- 使用工厂管理bean-satic静态管理 --&amp;gt; &amp;lt;bean name=&amp;#34;airFactory01&amp;#34; class=&amp;#34;factory.AirPlaneStaticFactory&amp;#34; factory-method=&amp;#34;getAirPlane&amp;#34;&amp;gt; &amp;lt;constructor-arg name=&amp;#34;name&amp;#34; value=&amp;#34;和风号&amp;#34;&amp;gt;&amp;lt;/constructor-arg&amp;gt; &amp;lt;/bean&amp;gt;   ioc容器取出bean
Object object = context.getBean(&amp;#34;airFactory01&amp;#34;); //注意此处的参数，使用的是xml中工厂类注册的名   返回值是工厂类所管理的bean，即Airplane对象
第二部分： 实例工厂   工厂类写法</description>
    </item>
    
    <item>
      <title>IOC注入方式</title>
      <link>https://linjinbao.github.io/2019/2019-11-07-ioc%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-07-ioc%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</guid>
      <description>2019-11-07-IOC注入方式 IOC注入多种复杂类型 简单类型注入 Person.java
public class Person { private Integer id; private String name; private String gender; ... } ioc.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;quot;&amp;gt; &amp;lt;bean id = &amp;quot;Person01&amp;quot; class=&amp;quot;entity.Person&amp;quot;&amp;gt; &amp;lt;property name=&amp;quot;id&amp;quot; value=&amp;quot;1151301118&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;linjinbao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;property name=&amp;quot;gender&amp;quot; value=&amp;quot;男&amp;quot;&amp;gt;&amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; 注入另一个bean Person.java
public class Person { private Integer id; private String name; private String gender; private Car car; //另外一个bean  ... } Car.java
public class Car { private String name; private double price; .</description>
    </item>
    
    <item>
      <title>MySQL索引</title>
      <link>https://linjinbao.github.io/2019/2019-11-06-mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-06-mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>MySQL索引底层实现原理 索引的本质 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。
索引的创建 CREATE INDEX indexName ON mytable(username(length)); 查看索引 show index from tableName; 删除索引 DROP index indexName on tableName 唯一索引 唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：
CREATE unique index indexName on tableName(username(length)); 测试样例：
mysql&amp;gt; show index from test2; +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | test2 | 1 | myIndex | 1 | name | A | 0 | 10 | NULL | | BTREE | | | +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 1 row in set </description>
    </item>
    
    <item>
      <title>mysql权限设置</title>
      <link>https://linjinbao.github.io/2019/2019-11-05-mysql%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-05-mysql%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
      <description>mysql 用户和权限控制  添加用户  //只允许指定ip连接 create user &amp;#39;新用户名&amp;#39;@&amp;#39;localhost&amp;#39; identified by &amp;#39;密码&amp;#39;; //允许所有ip连接（用通配符%表示） create user &amp;#39;新用户名&amp;#39;@&amp;#39;%&amp;#39; identified by &amp;#39;密码&amp;#39;;  为新用户授权  //基本格式如下 grant all privileges on 数据库名.表名 to &amp;#39;新用户名&amp;#39;@&amp;#39;指定ip&amp;#39; identified by &amp;#39;新用户密码&amp;#39; ; //示例 //允许访问所有数据库下的所有表 grant all privileges on *.* to &amp;#39;新用户名&amp;#39;@&amp;#39;指定ip&amp;#39; identified by &amp;#39;新用户密码&amp;#39; ; //指定数据库下的指定表 grant all privileges on test.test to &amp;#39;新用户名&amp;#39;@&amp;#39;指定ip&amp;#39; identified by &amp;#39;新用户密码&amp;#39; ;  设置用户操作权限  //设置用户拥有所有权限也就是管理员 grant all privileges on *.* to &amp;#39;新用户名&amp;#39;@&amp;#39;指定ip&amp;#39; identified by &amp;#39;新用户密码&amp;#39; WITH GRANT OPTION; //拥有查询权限 grant select on *.</description>
    </item>
    
    <item>
      <title>nginx反向代理和负载均衡</title>
      <link>https://linjinbao.github.io/2019/2019-11-05-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-05-nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid>
      <description>nginx反向代理   nginx yum地址
sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm   nginx配置
  /opt/nginx/nginx.conf
user root; # 用户，这里使用root用户，默认是nginx worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39; &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39; &amp;#39;&amp;#34;$http_user_agent&amp;#34; &amp;#34;$http_x_forwarded_for&amp;#34;&amp;#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; ## 导入其余配置 } /etc/nginx/conf.d/default.conf
server { listen 80; ## 监听的端口 server_name localhost; #charset koi8-r; #access_log /var/log/nginx/host.</description>
    </item>
    
    <item>
      <title>rpm工具用法</title>
      <link>https://linjinbao.github.io/2019/2019-11-04-rpm%E5%B7%A5%E5%85%B7%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-04-rpm%E5%B7%A5%E5%85%B7%E7%94%A8%E6%B3%95/</guid>
      <description>rpm工具用法  rpm -ivh * 安装软件包 rpm -Uvh 升级软件包 rpm -e 卸载软件包 rpm -qa 查看系统已经安装的rpm包 rpm -q 后面接包名，查询指定的包是否安装 rpm -qi 查询已安装的包的信息 rpm -ql 查询软件包安装了哪些文件 rpm -qf 查询一个文件是否那个包安装的  rpm安装traceroute  下载rpm包并上传到服务器 traceroute-2.0.22-2.el7.x86_64.rpm 执行命令 rpm -ivh tracrroute_**_.rpm traceroute ip  </description>
    </item>
    
    <item>
      <title>mysql主从配置</title>
      <link>https://linjinbao.github.io/2019/2019-11-01-mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-11-01-mysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE/</guid>
      <description>mysql 主从配置 分别安装主数据库和从数据库 ##下载源安装包 wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm ##安装mysql源 yum localinstall mysql57-community-release-el7-11.noarch.rpm ##检查 yum 源是否安装成功 yum repolist enabled|grep &amp;#34;mysql.*-community.*&amp;#34; ##安装服务 yum install mysql-community-server ##启动MySQL systemctl enable mysqld systemctl start mysqld systemctl status mysqld 修改密码之类步骤掠过
配置主数据库 vi /etc/my.cnf [mysqld] # 添加如下配置 # 参数必须唯一, 本例主库设置为 11 ，从库设置为 12 server_id=101 log_bin=/var/log/mysql/mysql-bin 记得检查日志目录是否存在，不存在子主动建立并授权
重启数据库
检查主库配置 mysql&amp;gt; show master; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 154 | | | | +------------------+----------+--------------+------------------+-------------------+ 配置从库 vi /etc/my.</description>
    </item>
    
    <item>
      <title>MyBatis Generator 使用</title>
      <link>https://linjinbao.github.io/2019/2019-10-30-mybatis-generator%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-30-mybatis-generator%E4%BD%BF%E7%94%A8/</guid>
      <description>MyBatis Generator使用 第一步：建立Maven工程 第二步：配置相关依赖 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.7&amp;lt;/version&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 第三步：创建 configuration 文件  注意修改其中的数据库连接方式 修改数据库驱动路径 修改表名  &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;!DOCTYPE generatorConfiguration PUBLIC &amp;quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&amp;quot; &amp;quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&amp;quot;&amp;gt; &amp;lt;generatorConfiguration&amp;gt; &amp;lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&amp;gt; &amp;lt;classPathEntry location=&amp;quot;D:\code\mybatisGen\mysql-connector-java-5.0.8-bin.jar&amp;quot;/&amp;gt; &amp;lt;context id=&amp;quot;DB2Tables&amp;quot; targetRuntime=&amp;quot;MyBatis3&amp;quot;&amp;gt; &amp;lt;commentGenerator&amp;gt; &amp;lt;property name=&amp;quot;suppressDate&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&amp;gt; &amp;lt;property name=&amp;quot;suppressAllComments&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; &amp;lt;/commentGenerator&amp;gt; &amp;lt;!--数据库链接URL，用户名、密码 --&amp;gt; &amp;lt;jdbcConnection driverClass=&amp;quot;com.mysql.jdbc.Driver&amp;quot; connectionURL=&amp;quot;jdbc:mysql://127.0.0.1/mqtt&amp;quot; userId=&amp;quot;root&amp;quot; password=&amp;quot;Gepoint&amp;quot;&amp;gt; &amp;lt;/jdbcConnection&amp;gt; &amp;lt;javaTypeResolver&amp;gt; &amp;lt;property name=&amp;quot;forceBigDecimals&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt; &amp;lt;/javaTypeResolver&amp;gt; &amp;lt;!-- 生成模型的包名和位置--&amp;gt; &amp;lt;javaModelGenerator targetPackage=&amp;quot;com.</description>
    </item>
    
    <item>
      <title>MySQL 事务</title>
      <link>https://linjinbao.github.io/2019/2019-10-29-mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 29 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-29-mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>2019-10-29-MySQL事务 MySQL事务 什么是事务 事务指的是当 DML 数据修改语句提交给数据库后，要么数据全部成功写入、如若其中某项操作失败则所有数据全部回滚到修改前状态的机制。数据库通过事务保证数据的完整性、一致性。
ACID 一个完整的事务，必然包含了如下4个特性：原子性、一致性、隔离性、持久性。
   类别 描述     原子性（Atomicity） 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。   一致性（Consistency） 事务应确保数据库的状态从一个一致状态转变成另一个一致状态。一致状态的含义是数据库应满足完整性约束。   隔离性（Isolation） 多个事务并发执行时，一个事务的执行不影响其他事务的执行   持久性（Durability） 已被提交的事务对数据库的修改应该永久保存在数据库中。    多线程并发事务问题 在多线程环境中，对于同一条数据而言可能有多个线程同时在进行修改操作，即带来了操作冲突。按照并发控制理论，要想解决冲突的问题，可以有如下两种思路：
 避免冲突发生，如串行化，加锁等； 允许冲突发生，即允许数据有多个版本，如使用MVCC  同时，多线程事务还存在隔离性的问题，当多个事务并发执行的时候，一个事务中能否感知到另外一个事务中的数据修改。数据库理论中专门定义了一系列的术语来描述：
   术语 简介     脏读 一个事务可以读到另外一个事务中未提交的数据。这往往会造成数据不一致   不可重复读 同一事务中两次读取同一行，数据不一致的情况称为不可重复读   幻读 同一事务中通过统计或其他汇总语句统计出来的数据不一致的情况    为解决上述问题，数据库提出了事务隔离级别来与之对应。从下表可以看出，一致性越好，并发能力越差。
   隔离级别 脏读 不可重复读 幻读     读未提交(Read Uncommit) 有 有 有   读已提交(Read Commit) 无 有 有   可重复读(Read Uncommit) 无 无 有   串行化(Read Uncommit) 无 无 无    InnoDB 事务 在计算机领域，数据一致性、与数据崩溃恢复通常是通过 WAL（Write Ahead Log） 技术来实现的——用户如果对数据库中的数据就行了修改，必须保证日志先于数据落盘。在InnoDB 引擎中，通过binlog 与redolog 的两段提交的方式（在事务执行前先写redolog，执行结束前写binlog）保证了数据的一致性和完整性，如若数据刷盘的过程中发生了异常，那么当MySQL重启的时候，根据日志对数据进行恢复，就可以还原数据，保证数据的一致性。在MySQL中，日志文件是最重要的数据，而数据文件反而没有那么重要。</description>
    </item>
    
    <item>
      <title>java堆溢出演示</title>
      <link>https://linjinbao.github.io/2019/2019-10-25-java%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%94%E7%A4%BA/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-25-java%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%94%E7%A4%BA/</guid>
      <description>java堆溢出演示-OutOfMemoryError jvm 参数 -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError 代码示例 import java.util.ArrayList; import java.util.List; public class HeapOOM { static class OOMObject{ } public static void main(String[] args) { List&amp;lt;OOMObject&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); while(true) { list.add(new OOMObject()); } } } 结果 java.lang.OutOfMemoryError: Java heap space Dumping heap to java_pid17808.hprof ... Heap dump file created [27978623 bytes in 0.066 secs] Exception in thread &amp;#34;main&amp;#34; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Unknown Source) at java.util.Arrays.copyOf(Unknown Source) at java.</description>
    </item>
    
    <item>
      <title>并发诀窍清单</title>
      <link>https://linjinbao.github.io/2019/2019-10-25-%E5%B9%B6%E5%8F%91%E8%AF%80%E7%AA%8D%E6%B8%85%E5%8D%95/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-25-%E5%B9%B6%E5%8F%91%E8%AF%80%E7%AA%8D%E6%B8%85%E5%8D%95/</guid>
      <description>并发诀窍清单-摘自《java并发编程实践》   可变状态
所有并发问题都归结为如何协调并发状态，可变状态越少，保证线程安全就越容易
  尽量将域声明称final类型，除非他们的需要是可变的。
  不可变对象天生是线程安全的。
  不可变对象极大的减轻了并发编程的压力，他们简单而且安全，可以在没有锁的情况下自由的共享。
  封装使得管理复杂度变得更可行。
在对象中封装数据，使得他们更加容易的保持不变；在对象中封装同步，使他更能够遵循同步规则。
  用锁来守护每一个可变变量
  对同一不变约束中的所有变量都使用相同的锁。
  在运行复合操作期间持有锁。
  在非同步的多线程情况下，访问可变变量额程序是存在隐患的。
  不要依赖于可以需要同步的小聪明。
  在设计过程中就考虑线程安全，或者在文档中明确的说明它不是想成安全的。
  文档化同步策略
  </description>
    </item>
    
    <item>
      <title>Linux 网卡配置</title>
      <link>https://linjinbao.github.io/2019/2019-10-23-linux%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-23-linux%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AE/</guid>
      <description>Linux 网卡配置 1：临时修改： 1.1：修改IP地址 ifconfig eth0 192.168.100.100
1.2：修改网关地址 route add default gw 192.168.100.1 dev eth0
1.3：修改DNS echo &amp;quot;nameserver 8.8.8.8&amp;quot; &amp;gt;&amp;gt; /etc/resolv.conf
这个时候就可以上网了，上网的IP地址为192.168.100.100，网关地址为192.168.100.1。但是这样的设置是临时性的，一旦重启网卡或者重启服务器，除了1.3的操作其他均会被还原，这样的方式只适合临时IP修改，想要永久性修改网卡配置文件，就需要修改相应的文件
2：永久性修改： 2.1：修改IP地址 修改/etc/sysconfig/network-scripts/ifcfg-eth0文件，如果有多张网卡，则修改相应的网卡
vi /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 #网卡对应的设备别名 BOOTPROTO=static #网卡获得ip地址的方式（默认为dhcp，表示自动获取） HWADDR=00:07:E9:05:E8:B4 #网卡MAC地址（物理地址） IPADDR=192.168.100.100 #IP地址 NETMASK=255.255.255.0 #子网掩码 ONBOOT=yes #系统启动时是否激活此设备 2.2：修改网关地址 修改/etc/sysconfig/network文件
vi /etc/sysconfig/network NETWORKING=yes #表示系统是否使用网络，no表示不能使用网络 HOSTNAME=doiido #设置本机的主机名，要和/etc/hosts中设置的主机名相同 GATEWAY=192.168.100.1 #设置网关的IP地址 这个时候已经可以ping通IP地址，但是还无法ping通域名，因此需要修改DNS
2.3：修改DNS 修改/etc/resolv.conf文件
vi /etc/resolv.conf nameserver 8.8.8.8 #google域名服务器 nameserver 114.144.114.114 #国内域名服务器 2.4：重启网卡
service network restart 正在关闭接口 eth0： [确定] 关闭环回接口： [确定] 弹出环回接口： [确定] 弹出界面 eth0： [确定] 命令： route</description>
    </item>
    
    <item>
      <title>整数传罗马数字</title>
      <link>https://linjinbao.github.io/2019/2019-10-23-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-23-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid>
      <description>整数传罗马数字-leetcode算法题 题目描述
罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</description>
    </item>
    
    <item>
      <title>最长公共前缀</title>
      <link>https://linjinbao.github.io/2019/2019-10-23-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-23-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>LeetCode 算法题-最长公共前缀 题目描述： 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。
示例 1: 输入: [&amp;#34;flower&amp;#34;,&amp;#34;flow&amp;#34;,&amp;#34;flight&amp;#34;] 输出: &amp;#34;fl&amp;#34; 示例 2: 输入: [&amp;#34;dog&amp;#34;,&amp;#34;racecar&amp;#34;,&amp;#34;car&amp;#34;] 输出: &amp;#34;&amp;#34; 解释: 输入不存在公共前缀。 说明:
所有输入只包含小写字母 a-z 。
题目分析  假设字符串数组的第一个全部作为结果 逐步缩短  代码示例 package easy; /** * 最长公共前缀 */ public class E14 { public String longestCommonPrefix(String[] strs) { int len = strs.length; if (len==0) return &amp;#34;&amp;#34;; if (len==1) return strs[0]; String str = strs[0]; for (int i=1; i &amp;lt; strs.length; i++){ while (strs[i].indexOf(str)!=0){ str = str.</description>
    </item>
    
    <item>
      <title>Centos 7 下编译openjdk</title>
      <link>https://linjinbao.github.io/2019/2019-10-22-openjdk%E7%BC%96%E8%AF%91/</link>
      <pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-22-openjdk%E7%BC%96%E8%AF%91/</guid>
      <description>openjdk编译 最近在学习java虚拟机的技术，尝试下手动编译openjdk
准备工作  CentOS7 环境 openjdk8 源码 bootstrap jdk源码（我用的是openjdk 7）  注意事项：
  目标jdk版本号比bootstrap jdk 大1
  准备可能需要安装各种编译工具
```code
yum -y install build-essential gawk m4 libasound2-print-dev binutils libmotif3 libmotif-dev ant
  yum install libX*
## 准备目标`jdk`和`bootstrap jdk` ```code ## 目标jdk，openjdk8 unzip openjdk-8-src-b132-03_mar_2014.zip 解压完成会得到一个openjdk文件夹，里面目录如下：
[root@localhost openjdk8]# ll total 348 -rwxrwxrwx. 1 root root 1503 Mar 4 2014 ASSEMBLY_EXCEPTION drwxr-xr-x. 3 root root 89 Oct 22 14:03 build drwxrwxrwx.</description>
    </item>
    
    <item>
      <title>日常学习</title>
      <link>https://linjinbao.github.io/2019/2019-10-22-%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-22-%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0/</guid>
      <description>2019-10-22-日常笔记 Linux分卷压缩和解压缩 1.将分卷的文件合并成一个文件
cat inpectWeb.zip.* &amp;gt; inspectWeb.zip
2.解压合并后的文件
unzip -zvf inspectWeb.zip
CCache安装 wget https://www.samba.org//ftp/ccache/ccache-3.6.tar.xz tar -xvf ccache-3.6.tar.xz cd ccache-3.6 ./configure -prefix=/var/ccache make -j8 make install ln -s /var/ccache/bin/ccache /usr/bin/ccache </description>
    </item>
    
    <item>
      <title>删除排序数组中的重复项</title>
      <link>https://linjinbao.github.io/2019/2019-10-21-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-21-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>删除排序数组中的重复项 题目描述 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2],
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
你不需要考虑数组中超出新长度后面的元素。
示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
说明:
为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums);
// 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); }
分析：双指针 代码示例 package easy; /** * 删除排序数组中的重复项 [1,1,2] */ public class E26 { public int removeDuplicates(int[] nums) { int len = nums.</description>
    </item>
    
    <item>
      <title>Vmware虚拟机Linux修改磁盘大小</title>
      <link>https://linjinbao.github.io/2019/2019-10-18-linux%E4%BF%AE%E6%94%B9%E7%A3%81%E7%9B%98%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-18-linux%E4%BF%AE%E6%94%B9%E7%A3%81%E7%9B%98%E5%A4%A7%E5%B0%8F/</guid>
      <description>Linux修改磁盘大小 注明： 1. 教程是在Vmware虚拟机环境下制作 2. 真机和这个差不多，只是第一步不一样
第一步 在Vmware中进行分配磁盘大小 如图所示： 第二步：fdisk命令 fdisk /dev/sda p　查看已分区数量（我看到有两个 /dev/sda1 /dev/sda2） n　新增加一个分区 p　分区类型我们选择为主分区 分区号输入3（因为1,2已经用过了,sda1是分区1,sda2是分区2,sda3分区3） 回车　默认（起始扇区） 回车　默认（结束扇区） t　修改分区类型 选分区3 8e　修改为LVM（8e就是LVM） w　写分区表 q　完成，退出fdisk命令 第三步：添加新LVM到已有的LVM组，实现扩容 lvm　进入lvm管理 lvm&amp;gt;pvcreate /dev/sda3　这是初始化刚才的分区3 lvm&amp;gt;vgextend centos /dev/sda3 将初始化过的分区加入到虚拟卷组centos (卷和卷组的命令可以通过 vgdisplay ) vm&amp;gt;vgdisplay lvm&amp;gt;lvextend -l+6793 /dev/mapper/centos-root　扩展已有卷的容量（6793 是通过vgdisplay查看free PE /Site的大小） lvm&amp;gt;pvdisplay 查看卷容量，这时你会看到一个很大的卷了 lvm&amp;gt;quit 退出 第四步：文件系统的扩容 xfs_growfs /dev/mapper/centos-root 查看结果-扩容了30G [root@192-168-200-130 ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/mapper/centos-root 47G 17G 31G 36% / devtmpfs 475M 0 475M 0% /dev tmpfs 487M 0 487M 0% /dev/shm tmpfs 487M 7.</description>
    </item>
    
    <item>
      <title>Docker完整打包一个项目</title>
      <link>https://linjinbao.github.io/2019/2019-10-17-docker%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-17-docker%E5%AE%8C%E6%95%B4%E6%89%93%E5%8C%85%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/</guid>
      <description>2019-10-17-Docker完整打包一个项目 Docker完整打包项目 使用Docker打包一个完整的项目，开箱即用的那种 包含以下内容：
 MySQL，完整数据库 Tomcat web系统mqtt  项目背景 说明： 这个项目是我以前做的一个项目，关于物联网Iot的项目，包含web端和设备端； web端运行在浏览器，是系统的后台，设备端运行在智能设备上（智能香薰仪）；项目使用阿里云的IotSDK和其提供的云端api； 项目不够成熟，希望大家指点
示意图：
设备端 &amp;lt;=&amp;gt; 阿里云 &amp;lt;=&amp;gt; 服务端
已经实现的功能：
 全局消息广播 产品的信息查询，从产品新增设备 设备的状态查询，历史记录追踪，设备的上线、下线控制 设备监控，上线提醒，下线提醒 设备属性修改 用户登录  待实现功能：
  用户权限模块
  设备的ecahrts展示
。。。
  步骤  编写DockerFile 打包镜像 上传  编写DockerFile tomcatDocFile
[root@localhost ~]# cat tomcatDocFile FROM tomcat ADD mqtt2.war /usr/local/tomcat/webapps/ CMD [&amp;#34;catalina.sh&amp;#34;,&amp;#34;run&amp;#34;] MAINTAINER linjinbao666@gmail.com EXPOSE 8080 EXPOSE 80 [root@localhost ~]# mysqlDocFile
[root@localhost ~]# cat mysqlDocFile FROM mysql:5.</description>
    </item>
    
    <item>
      <title>firewalld防火墙使用</title>
      <link>https://linjinbao.github.io/2019/2019-10-16-firewalld%E9%98%B2%E7%81%AB%E5%A2%99%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-16-firewalld%E9%98%B2%E7%81%AB%E5%A2%99%E4%BD%BF%E7%94%A8/</guid>
      <description>2019-10-16-firewalld防火墙使用 firewalld动态防火墙 firewalld 服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持 ipv4 与 ipv6，并支持网桥，采用 firewall-cmd (command) 或 firewall-config (gui) 来动态的管理 kernel netfilter 的临时或永久的接口规则，并实时生效而无需重启服务。
firewalld相关命令 systemctl start firewalld systemctl stop firewalld systemctl status firewalld systemctl enable firewalld firewall-cmd基本使用 firewall-cmd用来管理端口
firewall-cmd相关命令(对域操作) firewall-cmd --state //查看状态 firewall-cmd --zone=public --add-port=80/tcp --permanent //开启指定端口 firewall-cmd --reload //刷新，必要步骤 firewall-cmd --zone=public --list-ports //查看开放端口 firewall-cmd --zone=public --remove-port=80/tcp 两种管理方式  zone域模式管理，包括9个等级的域 service管理，内置了很多服务，以及配置了其对应端口，例如http的80端口，https的443端口  [root@localhost ~]# firewall-cmd --get-service RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bgp bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry docker-swarm dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master git gre high-availability http https imap imaps ipp ipp-client ipsec irc ircs iscsi-target jenkins kadmin kerberos kibana klogin kpasswd kprop kshell ldap ldaps libvirt libvirt-tls managesieve mdns minidlna mongodb mosh mountd ms-wbt mssql murmur mysql nfs nfs3 nmea-0183 nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius redis rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh syncthing syncthing-gui synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client upnp-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server zabbix-agent zabbix-server [root@localhost ~]# 9个域  drop 任何接收到的网络数据都被丢弃，没有任何回复，公有发送出去的网络连接 block 任何接收的网络连接都被IPV4 的icmp-host-prohibited信息和IPV6的icmp6-adm-prohibited信息所拒绝 public 在公共区域内使用，不能相信网络内的其它计算机不会对你的计算机造成危害，只接收经过选取的连接 external 特别是为路由器启用了伪装功能的外部网。你不能信任来自网络的其它计算，不能信任它们不会对你的计算机造成危害，只能接收经过选择的连接 dmz 用于你的非军事区的电脑 ，此区域内可公开访问，可以有限的进入你的内部网络，仅接收经过选择的连接 work 可以基本信任网络内的其它计算机不会危害你的计算机，仅接收经过选择的连接。 home 用于家庭网络，可以基本信任网络内的其它计算机不会危害你的计算机，仅接收经过选择的连接。 internal 用于内部网络，可以基本信任网络内的其它计算机不会危害你的计算机，仅接收经过选择的连接 trusted 可接收所有的网络连接  直接修改配置文件管理端口 cat /etc/firewalld/zones/public.</description>
    </item>
    
    <item>
      <title>leetcode题目-罗马数字转整数</title>
      <link>https://linjinbao.github.io/2019/2019-10-16-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-16-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      <description>2019-10-16-罗马数字转整数 题目描述 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</description>
    </item>
    
    <item>
      <title>Nginx使用</title>
      <link>https://linjinbao.github.io/2019/2019-10-16-nginx%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-16-nginx%E4%BD%BF%E7%94%A8/</guid>
      <description>2019-10-16-Nginx使用 Nginx使用 Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
Windows下的安装部署  下载软件  链接，Nginx下载地址
 解压启动  使用cmd命令行启动，start nginx
可能没有反馈提示，这时可以查看任务管理器是否有Nginx进程
 验证  访问lovalhost:80
页面内容：
Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. Linux下安装部署  添加repo文件  vi /etc/yum.repos.d/nginx.repo   搜索nginx</description>
    </item>
    
    <item>
      <title>rabbitMQ示例代码</title>
      <link>https://linjinbao.github.io/2019/2019-10-16-rabbitmq/</link>
      <pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-16-rabbitmq/</guid>
      <description>rabbitMQ 官网文档 涉及jar包amqp-client-5.7.3.jar
 发送  package myrabbitmq; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class Send { private final static String QUEUE_NAME = &amp;#34;hello&amp;#34;; private final static String IP = &amp;#34;localhost&amp;#34;; public static void main(String[] args) { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(IP); factory.setUsername(&amp;#34;guest&amp;#34;); factory.setPassword(&amp;#34;guest&amp;#34;); try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) { channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = &amp;#34;Hello World!&amp;#34;; channel.basicPublish(&amp;#34;&amp;#34;, QUEUE_NAME, null, message.getBytes()); System.</description>
    </item>
    
    <item>
      <title>base64转码</title>
      <link>https://linjinbao.github.io/2019/2019-10-15-base64%E8%BD%AC%E7%A0%81/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-15-base64%E8%BD%AC%E7%A0%81/</guid>
      <description>2019-10-15-base64转码 名词解释 Base64算法最早是为了解决电子邮件传输的问题的，早先的邮件传输协议中只支持ASCII码传递，如果要传输二进制文件，如图片和视频，是无法传输的，而BASE64可以将二进制文件内容编码成为只包含ASCII码的内容，这样就可以传输了。 Base64算法大家常常说成是加密算法，但准确的来说，Base64不是一种加密算法，只能算是一种基于64个字符的编码算法。 它有一个字符映射表，每个字符映射了一个十进制编码，共映射了64个字符。Base64将给定的数据经二进制转换后与字符映射表相对应，得到所谓的密文；映射表如下，映射表的最后是一个等号，是作为补位符用来补位的。
编号 字符 编号 字符 编号 字符 编号 字符 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / JAVA中Base64编码使用 涉及jdk工具类，java.</description>
    </item>
    
    <item>
      <title>windows共享开启</title>
      <link>https://linjinbao.github.io/2019/2019-10-15-windows%E5%85%B1%E4%BA%AB/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-15-windows%E5%85%B1%E4%BA%AB/</guid>
      <description>Windows共享命令  net share  C:\Users\linjinbao666&amp;gt;net share 共享名 资源 注解 ------------------------------------------------------------------------------- C$ C:\ 默认共享 D$ D:\ 默认共享 E$ E:\ 默认共享 F$ F:\ 默认共享 IPC$ 远程 IPC ADMIN$ C:\Windows 远程管理 命令成功完成。  net share blog=E:\amrom  PS E:\&amp;gt; net share blog=E:\amrom blog 共享成功。 PS E:\&amp;gt; net share 共享名 资源 注解 ------------------------------------------------------------------------------- IPC$ 远程 IPC C$ C:\ 默认共享 D$ D:\ 默认共享 E$ E:\ 默认共享 F$ F:\ 默认共享 ADMIN$ C:\Windows 远程管理 blog E:\amrom 命令成功完成。  删除共享目录  PS E:\&amp;gt; net share blog /del blog 已经删除。 PS E:\&amp;gt; net share 共享名 资源 注解 ------------------------------------------------------------------------------- C$ C:\ 默认共享 D$ D:\ 默认共享 E$ E:\ 默认共享 F$ F:\ 默认共享 IPC$ 远程 IPC ADMIN$ C:\Windows 远程管理 命令成功完成。 net use使用学习（重要） </description>
    </item>
    
    <item>
      <title>博客加入访问统计</title>
      <link>https://linjinbao.github.io/2019/2019-10-15/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-15/</guid>
      <description>2019-10-15-博客加入访问计数 博客加入访问统计 使用valine的实现
步骤  修改comments.html  将以下内容加入：
&amp;lt;p class=&amp;quot;copyright-item&amp;quot;&amp;gt; &amp;lt;span id=&amp;quot;{{ .RelPermalink | relURL }}&amp;quot; class=&amp;quot;leancloud_visitors&amp;quot; data-flag-title=&amp;quot;{{ .Title }}&amp;quot;&amp;gt; &amp;lt;span class=&amp;quot;post-meta-item-text&amp;quot;&amp;gt;Reading: 本文累计被阅读 &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;leancloud-visitors-count&amp;quot;&amp;gt;1000000&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;post-meta-item-text&amp;quot;&amp;gt;次&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; 加入后内容如下：
{{- if .Site.Params.valine.enable -}} &amp;lt;!-- id 将作为查询条件 --&amp;gt; &amp;lt;p class=&amp;quot;copyright-item&amp;quot;&amp;gt; &amp;lt;span id=&amp;quot;{{ .RelPermalink | relURL }}&amp;quot; class=&amp;quot;leancloud_visitors&amp;quot; data-flag-title=&amp;quot;{{ .Title }}&amp;quot;&amp;gt; &amp;lt;span class=&amp;quot;post-meta-item-text&amp;quot;&amp;gt;阅读次数: 本文累计被阅读 &amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;leancloud-visitors-count&amp;quot;&amp;gt;1000000&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;post-meta-item-text&amp;quot;&amp;gt;次&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;div id=&amp;quot;vcomments&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script src=&amp;quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&#39;//unpkg.com/valine/dist/Valine.min.js&#39;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; new Valine({ el: &#39;#vcomments&#39; , appId: &#39;{{ .</description>
    </item>
    
    <item>
      <title>JAVA并发编程实战-笔记</title>
      <link>https://linjinbao.github.io/2019/2019-10-14/</link>
      <pubDate>Mon, 14 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-14/</guid>
      <description>JAVA并发编程实战-笔记 Volatile变量
 同步的弱形式 该变量不会被缓存 不加锁 不会导致阻塞 可以修饰变量，不能修饰方法 只能保证可见性，不能保证原子性  线程封闭 访问共享的、可变的数据要求使用同步，一个可以避免同步的方法就是不共享数据。
 Ad-hoc线程限制 栈限制 ThreadLocal 不可变性   第二部分-构建并发应用 </description>
    </item>
    
    <item>
      <title>简单工程模式</title>
      <link>https://linjinbao.github.io/2019/2019-10-14-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 14 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-14-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>2019-10-14-工厂模式 含义  简单工厂模式又叫静态方法模式（因为工厂类定义了一个静态方法） 现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。  解决的问题 将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。
步骤  创建抽象产品类 &amp;amp; 定义具体产品的公共接口； 创建具体产品类（继承抽象产品类） &amp;amp; 定义生产的具体产品； 创建工厂类，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例； 外界通过调用工厂类的静态方法，传入不同参数从而创建不同具体产品类的实例  示例：  创建抽象产品类  abstract class Product{ public abstract void Show(); }  创建具体产品类  //具体产品类A class ProductA extends Product{ @Override public void Show() { System.out.println(&amp;#34;生产出了产品A&amp;#34;); } } //具体产品类B class ProductB extends Product{ @Override public void Show() { System.out.println(&amp;#34;生产出了产品C&amp;#34;); } } //具体产品类C class ProductC extends Product{ @Override public void Show() { System.</description>
    </item>
    
    <item>
      <title>jdk的代理Proxy使用</title>
      <link>https://linjinbao.github.io/2019/2019-10-12-%E4%BD%BF%E7%94%A8jdk%E4%BB%A3%E7%90%86/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-12-%E4%BD%BF%E7%94%A8jdk%E4%BB%A3%E7%90%86/</guid>
      <description>使用jdk的代理-Proxy动态代理 核心思想：反射，不改变原有代码，使用代理对象执行原有方法，侵入原始类内部 用处：解耦，切面编程
CalculatorProxy.java
public class CalculatorProxy { /** * 代理 * @param calcultor * @return */ public static Calcultor getCaluctor(Calcultor calcultor) { ClassLoader loader = calcultor.getClass().getClassLoader(); Class&amp;lt;?&amp;gt;[] interfaces = calcultor.getClass().getInterfaces(); InvocationHandler h = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&amp;#34;代理对象执行中，，，，，，，，，&amp;#34;); return method.invoke(calcultor, args); } }; return (Calcultor) Proxy.newProxyInstance(loader, interfaces, h); } } TestAOP.java
public class TestAOP { @Test public void test01() { Calcultor calcultor = new MyMathCaluctor(); Calcultor Proxy = CalculatorProxy.</description>
    </item>
    
    <item>
      <title>寻找两个有序数组的中位数</title>
      <link>https://linjinbao.github.io/2019/2019-10-12-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-12-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>2019-10-12-寻找两个有序数组的中位数 题目描述： 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
示例 1:
nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2:
nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 分析解答 这个题目是LeetCode上的hard题目，我的想法很简单，找出所有情况，可以提前结束循环的，就立即退出。 大概有以下几种：
 len1==0,len2!=0 len1!=0,len2==0 len1+len2为奇数 len1+len2为偶数  代码实现： package hard; import org.omg.PortableInterceptor.SYSTEM_EXCEPTION; /** * 寻找两个有序数组的中位数 */ public class H4 { public static double findMedianSortedArrays(int[] nums1, int[] nums2) { int len1 = nums1.</description>
    </item>
    
    <item>
      <title>Dart学习</title>
      <link>https://linjinbao.github.io/2019/2019-10-11-dart/</link>
      <pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-11-dart/</guid>
      <description>Dart 语法  代码片段  void main\(\) { for \(int i = 0; i &amp;amp;lt; 5; i++\) { print\(&amp;#39;hello ${i + 1}&amp;#39;\); prinfNUmber\(i\); } } prinfNUmber\(num number\){ print\(&amp;#39;The number is $number.&amp;#39;\); } 输出： ```code hello 1 The number is 0. hello 2 The number is 1. hello 3 The number is 2. hello 4 The number is 3. hello 5 The number is 4. 重要的概念  所有能够使用变量引用的都是对象， 每个对象都是一个类的实例。在 Dart 中 甚至连 数字、方法和 null 都是对象。所有的对象都继承于 Object 类。 使用静态类型(例如前面示例中的 num ) 可以更清晰的表明你的意图，并且可以让静态分析工具来分析你的代码， 但这并不是牵制性的。（在调试代码的时候你可能注意到 没有指定类型的变量的类型为 dynamic。） Dart 在运行之前会先解析你的代码。你可以通过使用 类型或者编译时常量来帮助 Dart 去捕获异常以及 让代码运行的更高效。 Dart 支持顶级方法 (例如 main())，同时还支持在类中定义函数。 （静态函数和实例函数）。 你还可以在方法中定义方法 （嵌套方法或者局部方法）。 同样，Dart 还支持顶级变量，以及 在类中定义变量（静态变量和实例变量）。 实例变量有时候被称之为域（Fields）或者属性（Properties）。 和 Java 不同的是，Dart 没有 public、 protected、 和 private 关键字。如果一个标识符以 (_) 开头，则该标识符 在库内是私有的。详情请参考： 库和可见性。 标识符可以以字母或者 _ 下划线开头，后面可以是 其他字符和数字的组合 有时候 表达式 expression 和 语句 statement 是有区别的，所以这种情况我们会分别指明每种情况 Dart 工具可以指出两种问题：警告和错误。 警告只是说你的代码可能有问题， 但是并不会阻止你的代码执行。 错误可以是编译时错误也可以是运行时错误。遇到编译时错误时，代码将 无法执行；运行时错误将会在运行代码的时候导致一个 异常。  关键字 下表为 Dart 语言的关键字。</description>
    </item>
    
    <item>
      <title>牛客网题目-栈的压入、弹出序列</title>
      <link>https://linjinbao.github.io/2019/2019-10-11-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-11-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid>
      <description>2019-10-11-栈的压入、弹出序列 题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
分析 1.辅助栈 2.找到弹出的位置
代码实现 package nowcoder; import java.util.Stack; /** * 栈的压入、弹出序列 */ public class IsPopOrder { public boolean isPopOrder(int [] pushA,int [] popA) { if (pushA.length==0 || popA.length==0) return false; Stack&amp;lt;Integer&amp;gt; stack = new Stack(); int popIndex = 0; for (int i=0; i&amp;lt; pushA.length; i++){ stack.push(pushA[i]); while (!stack.isEmpty() &amp;amp;&amp;amp; stack.peek()==popA[popIndex]){ stack.pop(); popIndex++; } } return stack.isEmpty(); } } </description>
    </item>
    
    <item>
      <title>webpack学习</title>
      <link>https://linjinbao.github.io/2019/2019-10-10-webpack/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-10-webpack/</guid>
      <description>webpack学习 安装 //全局安装 npm install -g webpack npm install -g webpack-cli npm install --save lodash //安装到你的项目目录 npm install --save-dev webpack 创建package.json文件 npm init 创建目录结构 webpack-demo |- /dist |- index.html |- /src |- index.js |- package.json src/index.js
function component() { var element = document.createElement(&amp;#39;div&amp;#39;); // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 element.innerHTML = _.join([&amp;#39;Hello&amp;#39;, &amp;#39;webpack&amp;#39;], &amp;#39; &amp;#39;); return element; } document.body.appendChild(component()); dist/index.html
&amp;lt;!doctype html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;起步&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/lodash@4.16.6&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script src=&amp;#34;./src/index.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; package.</description>
    </item>
    
    <item>
      <title>包含min函数的栈</title>
      <link>https://linjinbao.github.io/2019/2019-10-10-%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-10-%E7%89%9B%E5%AE%A2%E7%BD%91-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>牛客网题目-包含min函数的栈 题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
解法一 双栈实现，数据栈加最小值栈 代码如下：
import java.util.Stack; public class Solution { Stack&amp;lt;Integer&amp;gt; dataStack = new Stack(); Stack&amp;lt;Integer&amp;gt; minStack = new Stack&amp;lt;&amp;gt;(); public void push(int node) { dataStack.push(node); if (minStack.isEmpty() || node&amp;lt;minStack.peek())minStack.push(node); else minStack.push(minStack.peek()); } public void pop() { dataStack.pop(); minStack.pop(); } public int top() { return dataStack.peek(); } public int min() { return minStack.peek(); //辅助栈取值  } } 解法二 栈+ArrayList实现 代码如下：
import java.util.Stack; import java.util.ArrayList; import java.util.List; public class Solution { Stack&amp;lt;Integer&amp;gt; dataStack = new Stack(); List&amp;lt;Integer&amp;gt; minList = new ArrayList&amp;lt;&amp;gt;(); public void push(int node) { dataStack.</description>
    </item>
    
    <item>
      <title>java创建线程的7种方式</title>
      <link>https://linjinbao.github.io/2019/2019-10-09-java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-09-java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>java创建线程的7种方式  继承Thread类并重写run()方法  public class MyThread extends Thread { @Override public void run() { System.out.println(this.getId()+this.getName()+ &amp;#34; is running&amp;#34;); } public static void main(String[] arg){ new MyThread().start(); new MyThread().start(); new MyThread().start(); new MyThread().start(); } } $ &amp;#34;C:\Program Files\Java\jdk1.8.0_171\bin\java.exe&amp;#34; 12Thread-0 is running 15Thread-3 is running 13Thread-1 is running 14Thread-2 is running Process finished with exit code 0  实现Runnable接口  public class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+&amp;#34; is running&amp;#34;); } public static void main(String[] args){ new Thread(new MyThread()).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://linjinbao.github.io/2019/2019-10-03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/</link>
      <pubDate>Thu, 03 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-10-03-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97%E5%9C%86%E5%91%A8%E7%8E%87/</guid>
      <description>多线程计算圆周率 使用公式1-1/3+1/5&amp;hellip;&amp;hellip;
代码示例 package learn; import java.math.BigDecimal; import java.util.ArrayList; import java.util.concurrent.*; /** * 多线程计算圆周率 */ public class Pie { public static double sum = 0.0; public static void main(String[] args) throws ExecutionException, InterruptedException { int tNum = 64; ExecutorService pool = Executors.newFixedThreadPool(tNum); ArrayList&amp;lt;Future&amp;lt;BigDecimal&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); long tmp = 1000000000; long time0 = System.currentTimeMillis(); System.out.println(&amp;#34;开始计算时间：&amp;#34;+time0); for (int i=0; i&amp;lt; tNum; i++){ long start = 1+tmp*i; long end = start+tmp-1; Callable&amp;lt;BigDecimal&amp;gt; caller = new Pie().</description>
    </item>
    
    <item>
      <title>LeetCode周赛-第 156 场</title>
      <link>https://linjinbao.github.io/2019/2019-09-29-leetcode-156/</link>
      <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-29-leetcode-156/</guid>
      <description>LeetCode周赛-第 156 场  排名630 / 1432
 题目名称：
独一无二的出现次数
题目描述：
给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。
示例 1：
输入：arr = [1,2,2,1,1,3] 输出：true 解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2：
输入：arr = [1,2] 输出：false 提示：
 1 &amp;lt;= arr.length &amp;lt;= 1000 -1000 &amp;lt;= arr[i] &amp;lt;= 1000  解法思路： 第一步，用Map存储所有出现的字符以及出现的次数，第二部，使用Set将字符出现的次数进行比较，出现重复，则返回false。
代码：
public boolean uniqueOccurrences(int[] arr) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i=0;i&amp;lt;arr.length;i++){ if (map.containsKey(arr[i])){ int value = map.</description>
    </item>
    
    <item>
      <title>React学习笔记</title>
      <link>https://linjinbao.github.io/2019/2019-09-28-react/</link>
      <pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-28-react/</guid>
      <description>React学习 JSF语法概述 const element = &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;; 这个有趣的标签语法既不是字符串也不是 HTML。
它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。
实例
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- 生产环境中不建议使用 --&amp;gt; &amp;lt;script src=&amp;quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;quot;text/babel&amp;quot;&amp;gt; const name = &#39;linjinbao666&#39;; const element = &amp;lt;h1&amp;gt;hello, {name}&amp;lt;/h1&amp;gt; ReactDOM.render( element, document.getElementById(&#39;root&#39;) ); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 元素 元素是构成React应用的最小砖块
元素的渲染： const element = &amp;lt;h1&amp;gt;Hello, world&amp;lt;/h1&amp;gt;; ReactDOM.</description>
    </item>
    
    <item>
      <title>LeetCode算法题-合并区间</title>
      <link>https://linjinbao.github.io/2019/2019-09-27-leetcode%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-27-leetcode%E7%AE%97%E6%B3%95%E9%A2%98-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</guid>
      <description>2019-09-27-LeetCode算法题-合并区间 LeetCode算法题-合并区间 题目描述： 给出一个区间的集合，请合并所有重叠的区间。
示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路分析：
  对给出的二维数组进行排序，使得满足每一组第一个元素都小于等于后面一组第一个元素，例如这种形式：[[1,3],[2,6],[8,10]]。
[[1,3],[8,10],[2,6]]这种形式则需要调整。
  贪心给出一个新的结果二维数组，每次去和已知数组比较，发生重合则重组后加入结果数组，否则则将已知数组的拷贝过来。
  代码如下：
public static int[][] merge(int[][] intervals) { if (intervals.length==0) return new int[][]{}; if (intervals.length ==1) return intervals; //处理输入，使得每一个里面的第一个元素递增  for (int i=0; i&amp;lt;intervals.length-1; i++){ for (int j=0; j&amp;lt;intervals.length-1-i; j++){ if (intervals[j][0] &amp;gt; intervals[j+1][0]){ int[] tmp = intervals[j]; intervals[j] = intervals[j+1]; intervals[j+1] = tmp; } } } int[][] out = new int[intervals.</description>
    </item>
    
    <item>
      <title>MYSQL操作笔记</title>
      <link>https://linjinbao.github.io/2019/2019-09-27-mysql%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-27-mysql%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/</guid>
      <description>MYSQL操作笔记 修改用户密码 [官方链接]（https://dev.mysql.com/doc/mysql-windows-excerpt/5.7/en/resetting-permissions-windows.html） 方法一（老版本）：使用set password命令 格式`mysql&amp;gt; set password for username@loclhost=password(&amp;lsquo;passwd&amp;rsquo;);
mysql&amp;gt; set password = password(&amp;#39;Gepoint&amp;#39;); Query OK, 0 rows affected (0.36 sec) 方法二：使用alter命令
alter user &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; identified by &amp;#39;123321&amp;#39;; 方法三：修改user表
UPDATE mysql.user SET authentication_string = PASSWORD(&amp;#39;MyNewPass&amp;#39;), password_expired = &amp;#39;N&amp;#39; WHERE User = &amp;#39;root&amp;#39; AND Host = &amp;#39;localhost&amp;#39;; FLUSH PRIVILEGES; 定时任务   打开定时器
-- 开启event  SET GLOBAL event_scheduler=&amp;#39;ON&amp;#39;; -- 查看定时器  SHOW VARIABLES LIKE &amp;#39;event_scheduler&amp;#39;;   写存储过程供定时任务调用
```sql</description>
    </item>
    
    <item>
      <title>博客加入评论功能</title>
      <link>https://linjinbao.github.io/2019/2019-09-26-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8A%A0%E5%85%A5%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-26-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%8A%A0%E5%85%A5%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</guid>
      <description>2019-09-26-个人博客加入评论功能 个人博客加入评论功能 实现思路： 使用第三方存储，白嫖美滋滋
按照姑苏流白的教程，我使用Valine的评论系统
配置Valine  注册 登录账号 略过 建立应用 配置应用keys，配置项：AppID， AppKey  修改博客配置  修改config.toml配置  加入以下内容：
# Valine. # You can get your appid and appkey from https://leancloud.cn # more info please open https://valine.js.org [params.valine] enable = true appId = &#39;V6YqPB0nmoIcjHC9P5CXBMSB-gzGzoHsz&#39; appKey = &#39;hfkA0t8piT3MiYnUx936Msyd&#39; notify = false # mail notifier , https://github.com/xCss/Valine/wiki verify = false # Verification code avatar = &#39;mm&#39; placeholder = &#39;说点什么吧...&#39; visitor = true  创建comments.</description>
    </item>
    
    <item>
      <title>牛客网-二叉树的镜像</title>
      <link>https://linjinbao.github.io/2019/2019-09-26-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-26-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%9C%E5%83%8F/</guid>
      <description>二叉树镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。
分析： 想到递归，对每一个节点有4种情况：
 当前节点为空 当前节点不为空，左子树为空 当前节点不为空，右子树为空 当前节点不为空，左右子树都为空  很显然2,3两点可以重合
那么递归退出条件就是1和4
代码 代码如下，测试通过
public static void mirror(TreeNode root) { if (root==null)return; if (root.left==null &amp;amp;&amp;amp; root.right==null) return; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; mirror(root.left); mirror(root.right); } 总结 二叉树的递归，遵循以下几步：
 找出所有情况 确定退出条件 确定一般递归内容  这一题题目现在看来不难，但是我一开始想偏了，想利用一个辅助函数helper(TreeNode left, TreeNode right)来递归他的左子树和右子树，但是问题在于，每次交换左右子树都变化了，结果就是对于满二叉树可以完成，但是对于不是满二叉树就不行
欢迎大家转载我的博客菜鸡聪。 如果希望交流算法，欢迎联系我， Gmail</description>
    </item>
    
    <item>
      <title>RabbitMq安装部署</title>
      <link>https://linjinbao.github.io/2019/2019-09-25-rabbitmqwindows/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-25-rabbitmqwindows/</guid>
      <description>RabbitMq-Windows版本部署 软件下载  otp_win64_R16B03-1.exe rabbitmq-server-3.6.9.exe  软件安装一路下一步，全部使用默认地址
启动服务 进入C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-3.4.1\sbin目录，运行cmd，输入命令rabbitmq-plugins enable rabbitmq_management：
C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.9\sbin&amp;gt; rabbitmq-plugins enable rabbitmq_management The following plugins have been enabled: amqp_client cowlib cowboy rabbitmq_web_dispatch rabbitmq_management_agent rabbitmq_management Applying plugin configuration to rabbit@DESKTOP-I1CQLLJ... started 6 plugins. C:\Program Files\RabbitMQ Server\rabbitmq_server-3.6.9\sbin&amp;gt; 其他 相关命令：
停止：net stop RabbitMQ 启动：net start RabbitMQ 在浏览器中输入地址查看：http://127.0.0.1:15672/
使用默认账号登录：guest/ guest</description>
    </item>
    
    <item>
      <title>牛客网题目-树的子结构</title>
      <link>https://linjinbao.github.io/2019/2019-09-25-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-25-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>2019-09-25-树的子结构 题目名称：树的子结构 题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
分析： 第一想法是递归，只要是树，我就上递归。分析情况有以下3种：
 当前root1节点=当前root2节点 当前root1节点！=当前root2节点，但是root1.left和root2节点相等 当前root1节点！=当前root2节点，但是root1.right和root2节点相等  所以需要一个辅助函数helper
public static boolean hasSubtree(TreeNode root1, TreeNode root2) { if (root1==null || root2==null) return false; //三种情况  return helper(root1,root2) || hasSubtree(root1.left, root2) || hasSubtree(root1.right,root2); } //递归检查  public static boolean helper(TreeNode root1, TreeNode root2){ if (root2==null) return true; if (root1==null) return false; if (root1.val==root2.val)return helper(root1.left,root2.left)&amp;amp;&amp;amp;helper(root1.right,root2.right); return false; } 总结 遇到二叉树，递归总没错</description>
    </item>
    
    <item>
      <title>Mongodb安装与使用</title>
      <link>https://linjinbao.github.io/2019/2019-09-24-mongodb/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-24-mongodb/</guid>
      <description>Mongodb安装与使用 背景知识 最近在项目实施过程中遇到一个问题：由于客户提供的Linux机器没有最下滑化安装，导致使用公司的bin包方式安装Mongodb失败。本着能自己解决就自己解决的态度，我开始了Mongodb的研究。
安装和启动   下载
因为centos的官放的yum源中没有提供Mongodb的安装包，此时我们需要自己下载下来（也可以修改yum源，不推荐） 执行命令wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.0.tgz 下载安装包
  解压
执行解压命令tar zxvf mongodb-linux-x86_64-4.0.0.tgz，如果为了统一的化，可以把解压出来的文件夹重命名，以及移动到/opt/下去。这个不重要，可以不用看。
  添加启动配置
vi mongodb.conf 添加一下配置：
port=27017 #端口 bind_ip = 0.0.0.0 #这样就可外部访问了，例如从win10中去连虚拟机中的MongoDB fork=true#后台启动 logpath=/usr/mongodb/log/log.log dbpath=/usr/mongodb/db 其他配置不用管他，Mongodb会使用默认配置。
  设置权限
cd /usr/mongodb chmod 777 db chmod 777 log 管他呢，全部777
  启动服务
mongod --config mongodb.conf   修改用户 使用mongo修改用户，注意不是mongod
[root@jk-zhengwu03 bin]# ./mongo MongoDB shell version v4.0.0 connecting to: mongodb://127.0.0.1:27017 MongoDB server version: 4.0.0 Server has startup warnings: 2019-09-24T20:05:18.</description>
    </item>
    
    <item>
      <title>MySQL一键备份脚本</title>
      <link>https://linjinbao.github.io/2019/2019-09-24-mysql%E4%B8%80%E4%BB%B6%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-24-mysql%E4%B8%80%E4%BB%B6%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/</guid>
      <description>MySQL一键备份脚本 备份脚本-Windows版本 脚本下载
@echo off pause set year=%Date:~0,4% set month=%Date:~5,2% set day=%Date:~8,2% set address=f:\ set host=localhost set user=root set password=123321 set mysqlpath=D:\epoint_mysql_5.7.24\mysql-5.7.24-winx64\bin\mysqldump.exe set port=3306 rem 用户输入： set /p address=备份地址(例如：F:\) set /p mysqlpath=请输入MySQL安装，不输入则使用默认地址D:\epoint_mysql_5.7.24\mysql-5.7.24-winx64\bin\mysqldump.exe set /p host=请输入主机地址（默认localhost） set /p user=请输入数据库用户名：（默认root） set /p password=请输入数据库密码：(默认123321) set /p port=请输入端口号（默认3306） set /p dbname=请输入数据库名称 rem 用户输入结束： echo 用户输入结束，备份地址为%address%； 数据库用户名为：%user%；数据库密码为：%password%; pause set backupfile=%address%%year%-%month%-%day%-%dbname%.sql echo 备份文件: %backupfile% pause %mysqlpath% -u%user% -p%password% %dbname% &amp;gt; %backupfile% echo 请检查数据库备份是否成功，备份文件为%backupfile% echo 欢迎下次使用 pause exit 备份脚本-Linux版本 待续</description>
    </item>
    
    <item>
      <title>GitHub博客教程</title>
      <link>https://linjinbao.github.io/2019/2019-09-23-%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-23-%E5%8D%9A%E5%AE%A2/</guid>
      <description>GitHub博客 作为一名程序员，每天的学习必不可少，但是，如果只是乱糟糟的学习，而不懂得如何去记笔记，那效率可想而知。一个技术博客，是大多数程序员的必须品。漂亮的博客，让工作顺心，让学习更有效率，更有动力。今天，我来教大家如何利用GitHub提供的免费服务，打造自己的专属博客，白嫖美滋滋。
前期准备；   GitHub账号
  Hugo 软件
  Git客户端
  掌握Markdown语法
需要准备的东西就是这么多，账号去官网注册就行，几个软件下载安装就可以，具体怎么安装，以及如何跨平台啥的，这里不作阐述。需要注意的是Markdown语法一定要会，起码简单的语法懂得，因为写文章都要用Markdown来写，.md是他的标志。
  第一篇文章 准备好以上条件后，我们来写一篇博客
 建立博客目录  在硬盘目录建立一个空文件夹，可以任意命名，我这里是F:\，我放在了F盘根目录
 使用hugo生成站点  打开cmd，cd到F:\目录
$ hugo new site amrom 此时在F:\下的目录结构如下：
F:\&amp;gt;tree 卷 新加卷 的文件夹 PATH 列表 卷序列号为 F4A2-CDCD F:. └─amrom ├─archetypes ├─content │ ├─posts │ └─resources │ └─_gen │ ├─assets │ └─images ├─data ├─layouts ├─public ├─static │ └─images │ └─me └─themes ├─hyde │ ├─archetypes │ ├─images │ ├─layouts │ │ ├─partials │ │ └─_default │ └─static │ └─css ├─material-design │ ├─archetypes │ ├─images │ ├─layouts │ │ ├─partials │ │ └─_default │ └─static │ ├─css │ ├─font │ │ ├─material-design-icons │ │ └─roboto │ ├─images │ └─js ├─public │ ├─categories │ └─tags └─resources └─_gen ├─assets └─images F:\&amp;gt; 此处重点看文件夹目录和一级二级目录，因为我个目录结构和最初的变化过了，多了很多东西，例如下面的hyde和material-design是我下载自定义的主题</description>
    </item>
    
    <item>
      <title>windows常用批处理命令</title>
      <link>https://linjinbao.github.io/2019/2019-09-23-windows/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-23-windows/</guid>
      <description>Windows批处理 常用dos命令 echo 打印 dir 列文件名 cd　改变当前目录 ren 改变文件名 copy　拷贝文件 del 删除文件 md　建立子目录 rd　删除目录 deltree　删除目录树 format　格式化磁盘 edit　文本编辑 type　显示文件内容 mem 查看内存状况 ## 以下是新增加的命令 help　显示帮助提示 cls 清屏 move　移动文件，改目录名 more　分屏显示 xcopy 拷贝目录和文件 显示篇  echo @ 和 pause 在DOS命令提示符中使用 echo /?可以获得对 echo 用法的解释。echo on 用于打开命令的回显；echo off 用于关闭命令的回显(默认情况下，ehco 是处于打开状态的)。只输入 echo 可以获得当前的回显状态(是否处于打开状态)。输入 echo 再加一段文字，例如 echo Hello world! 可以显示出 Hello world! 这句信息。 @ ，如果在某一条命令最前面加上 @ ，那么这一行命令就不会显示出来。与 echo off 有着相似之处。 echo off 以后的所有命令本身都不再显示出来；而 @ 只是将当前那一行的命令不显示出来。然而，至于命令所产生的输出结果，仍然会显示出来。这看起来似乎有些拗口，但我们会通过例子来很容易地理解它们。 pause ，从字面上看就是暂停的意思，效果等同于将程序挂起，在按下任意键后才继续。 &amp;gt; 和 &amp;gt;&amp;gt; &amp;gt; 表示将输出结果打印到某处。比如： echo Hello world!</description>
    </item>
    
    <item>
      <title>合并两个排序的链表</title>
      <link>https://linjinbao.github.io/2019/2019-09-23-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-23-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>牛客网-合并两个排序的链表 题目描述： 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则
解答： package nowcoder; /** * 合并两个排序的链表 */ public class Merge { public static ListNode merge(ListNode list1,ListNode list2) { ListNode head = new ListNode(-1); head.next = null; ListNode root = head; while (list1!=null &amp;amp;&amp;amp; list2!=null){ if (list1.val &amp;lt; list2.val){ head.next = list1; head = list1; list1 = list1.next; }else { head.next = list2; head = list2; list2 = list2.next; } } if (list1==null)head.next = list1; if (list2==null)head.next = list2; return root.</description>
    </item>
    
    <item>
      <title>第155场周赛--LeetCode</title>
      <link>https://linjinbao.github.io/2019/2019-09-22-%E7%AC%AC155%E5%9C%BA%E5%91%A8%E8%B5%9B/</link>
      <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-22-%E7%AC%AC155%E5%9C%BA%E5%91%A8%E8%B5%9B/</guid>
      <description>第 155 场周赛&amp;ndash;LeetCode 第一题：最小绝对差 题目描述： 给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例 1：
输入：arr = [4,2,1,3] 输出：[[1,2],[2,3],[3,4]] 示例 2：
输入：arr = [1,3,6,10,15] 输出：[[1,3]] 示例 3：
输入：arr = [3,8,-10,23,19,-4,-14,27] 输出：[[-14,-10],[19,23],[23,27]] 提示：
 2 &amp;lt;= arr.length &amp;lt;= 10^5 -10^6 &amp;lt;= arr[i] &amp;lt;= 10^6  分析 先排序，遍历算最小差值
代码实现
package compete; import java.util.ArrayList; import java.util.Arrays; import java.util.List; /** * 最小绝对差 */ public class C5197 { public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; minimumAbsDifference(int[] arr) { if (arr.length&amp;lt;2) return null; Arrays.sort(arr); for (int i : arr){ System.</description>
    </item>
    
    <item>
      <title>netcat使用教程</title>
      <link>https://linjinbao.github.io/2019/2019-09-21-netcat%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-21-netcat%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid>
      <description>netcat使用教程 @author linjinbao666@gmail.com fork me on github
netcat简介 netcat 一般简称为 nc，直译为中文就是“网猫”，被誉为——【网络上的瑞士军刀】。它诞生于1995年，在网络安全社区的名气很大（就如同 AK47 在军事领域的名气）。长期在安全圈内混的人，应该都知道它。想当年，insecure.org 网站在本世纪初搞过几次“年度投票”，评选优秀的安全工具。每次投票，netcat 都能排进前几名。参考链接
nc命令行简介 形式： nc 命令选项 主机 端口 命令选项 这部分可能包含 0~N 个选项 （注：这部分最复杂，下一个小节单独聊） 主机 这部分可能没有，可能以“点分十进制”形式表示，也可能以“域名”形式表示。 端口 这部分可能没有，可能是单个端口，可能是端口范围（以减号分隔） 举例：
nc -l -p 12345 -v 在这个例子中，分别用到了三个选项（l、v、p），其中 12345 是选项 p 所带的【选项值】
常用的命令行选项    选项 是否有选项值 说明     h NO 输出 nc 的帮助   v NO 在网络通讯时，显示详细的输出信息   注：建议新手多用该选项，出错时帮你诊断问题| | n| No| 对命令行中的“主机”，【不】进行域名解析 | | p | YES | 指定“端口号” |     命令行合写形式：      nc -lp 12345 -v nc -l -v -p 12345 nc -lv -p 12345 nc -lvp 12345 使用场景一：（网络诊断）测试某个远程主机的【监听】端口是否可达 nc -nv x.</description>
    </item>
    
    <item>
      <title>排序算法总结</title>
      <link>https://linjinbao.github.io/2019/2019-09-14-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 14 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-14-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>排序总结 冒泡排序 原理：每次比较两个相邻的元素，将较大元素交换至右端 特点：每次循环结束，会出现一个排序好的元素，右侧 理解：大的数右移，重复此过程 代码：
public static void bubbleSort(int[] nums){ for (int i=0; i&amp;lt;nums.length-1; i++){ //第i次循环找出第i小的元素0&amp;lt;=i&amp;lt;=length-1  for (int j=0; j&amp;lt;nums.length-1-i; j++){ if (nums[j+1]&amp;lt;nums[j]){ int tmp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = tmp; } for (int num : nums) System.out.print(num+&amp;#34;\t&amp;#34;); System.out.println(); } } } 优化：使用flag标记是否已经有序
选择排序 原理：每次循环找出最小的元素于左侧，每次循环都从剩余未排序系列找出最小的元素 代码：
/** * 选择排序 * @param nums */ public static void selectSort(int[] nums){ int len = nums.length; if (len==0 || len==1) return; for (int i=0; i&amp;lt;len; i++){ for (int j=i+1; j&amp;lt;len; j++){ if (nums[j] &amp;lt; nums[i]){ int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } } } } 插入排序 原理：递归思想，假设第一个有序，则新插入一个，将其排序，循环递归 代</description>
    </item>
    
    <item>
      <title>Linux笔记</title>
      <link>https://linjinbao.github.io/2019/2019-09-13-linux%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 13 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-09-13-linux%E7%AC%94%E8%AE%B0/</guid>
      <description>笔记 查找软件包rsync rpm -qa | grep rsync 客户端拉取 rsync -av root@192.168.59.130::backup /home/ljbao/ 打印指定行数据 sed -n &amp;#39;10,10p&amp;#39; file.txt cat file.txt | head -n 10 | tail -n +10 awk使用 awk &amp;#39;{print $2} {print $1}&amp;#39; emp.data crond使用 service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置 service crond status //查看服务状态 第一步：写cron脚本文件,命名为crontest.cron。 15,30,45,59 * * * * echo &amp;quot;xgmtest.....&amp;quot; &amp;gt;&amp;gt; xgmtest.txt 表示，每隔15分钟，执行打印一次命令 第二步：添加定时任务。执行命令 crontab crontest.cron。搞定 第三步：crontab -l查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本</description>
    </item>
    
    <item>
      <title>Redis笔记</title>
      <link>https://linjinbao.github.io/2019/2019-07-29-redis%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 29 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-07-29-redis%E7%AC%94%E8%AE%B0/</guid>
      <description>Redis笔记 key-value结构 Redis目前有5种数据类型，分别是：
String（字符串） List（列表） Hash（字典） Set（集合） Sorted Set（有序集合） 不同的数据类型，有不同的命令方式
String 操作
set google http://www.google append google .com get google set visitors 0 incr visitors incr visitors get visitors incrby visitors 100 get visitors type google type visitors ttl google rename google google-site get google get google-site String 手册
SET key value 设置key=value GET key 获得键key对应的值 GETRANGE key start end 得到字符串的子字符串存放在一个键 GETSET key value 设置键的字符串值，并返回旧值 GETBIT key offset 返回存储在键位值的字符串值的偏移 MGET key1 [key2.</description>
    </item>
    
    <item>
      <title>MYSQL笔记</title>
      <link>https://linjinbao.github.io/2019/2019-07-28-mysql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-07-28-mysql%E7%AC%94%E8%AE%B0/</guid>
      <description>MYSQL笔记 UUID select uuid(); 存储过程 存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。 存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。 创建存储过程
DELIMITER // CREATE PROCEDURE getAllUsers() BEGIN SELECT * FROM `user`; END // DELIMITER ; CALL getAllUsers(); 调用存储过程
CALL getAllUsers(); 触发器 CREATE TRIGGER add_userTime BEFORE INSERT on `user` for each ROW INSERT INTO usercreatetime(create_time) VALUES(now()); 创建表 DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `account` varchar(255) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `address` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS `user_history`; CREATE TABLE `user_history` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `user_id` bigint(20) NOT NULL, `operatetype` varchar(200) NOT NULL, `operatetime` datetime NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 创建触发器 DROP TRIGGER IF EXISTS `tri_insert_user` delimiter ;; CREATE TRIGGER `tri_insert_user` AFTER INSERT ON `user` FOR EACH ROW BEGIN INSERT INTO user_history(user_id, operatetype, operatetime) VALUES (new.</description>
    </item>
    
    <item>
      <title>Docker常用操作教程</title>
      <link>https://linjinbao.github.io/2019/2019-07-05-docker/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-07-05-docker/</guid>
      <description>Docker笔记 Docker安装 yum install docker -ysystemctl start docker.servicesystemctl status docker.servicesystemctl stop docker.servicesystemctl start docker.servicesystemctl restart docker.servicesystemctl status docker.service####Docker卸载 1.搜索已经安装的Docker保
yum list installed|grep dockerrpm -qa|grep docker2.分别删除安装包
yum –y remove docker.x86_643.删除docker 镜像
rm -rf /var/lib/docker部署项目 1.配置DNS
nslookup www.baidu.comvi /etc/resolv.conf# Generated by NetworkManagersearch www.tendawifi.comnameserver 119.29.29.29nameserver 182.254.116.116nslookup www.baidu.com2.配置镜像加速器
sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39;{&amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://hvmf8r55.</description>
    </item>
    
    <item>
      <title>Docker常用操作教程</title>
      <link>https://linjinbao.github.io/2019/2019-07-05-docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-07-05-docker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%99%E7%A8%8B/</guid>
      <description>Docker常用操作教程 Docker笔记 Docker安装 yum install docker -y systemctl start docker.service systemctl status docker.service systemctl stop docker.service systemctl start docker.service systemctl restart docker.service systemctl status docker.service Docker卸载 1.搜索已经安装的Docker保
yum list installed|grep docker rpm -qa|grep docker 2.分别删除安装包
yum –y remove docker.x86_64 3.删除docker 镜像
rm -rf /var/lib/docker 部署项目 1.配置DNS
nslookup www.baidu.com vi /etc/resolv.conf # Generated by NetworkManager search www.tendawifi.com nameserver 119.29.29.29 nameserver 182.254.116.116 nslookup www.baidu.com 2.配置镜像加速器
sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39; { &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;https://hvmf8r55.</description>
    </item>
    
    <item>
      <title>ssm整合</title>
      <link>https://linjinbao.github.io/2019/2019-07-01-ssm%E6%95%B4%E5%90%88/</link>
      <pubDate>Mon, 01 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-07-01-ssm%E6%95%B4%E5%90%88/</guid>
      <description>ssm整合 pom.xml &amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;tk.amrom&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;crms&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;crms Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!-- FIXME change it to the project&#39;s website --&amp;gt; &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;spring.version&amp;gt;3.1.0.RELEASE&amp;lt;/spring.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--spring核心包--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.</description>
    </item>
    
    <item>
      <title>vue</title>
      <link>https://linjinbao.github.io/2019/2019-06-24-vue/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-06-24-vue/</guid>
      <description>vue学习 模板语法   v-html用于输出html代码；
  v-bind用于设置html属性中的值；
  指令
指令是带有v-前缀的特殊属性，指令用于在表达式的值改变时，将某些行为应用到 DOM 上；
  参数，参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性；
  修饰符，修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用；
&amp;lt;form v-on:submit.prevent=&amp;#34;onSubmit&amp;#34;&amp;gt;&amp;lt;/form&amp;gt;   用户输入，在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定
v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值
  过滤器
Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由&amp;quot;管道符&amp;quot;指示, 格式如下；
&amp;lt;div v-bind:id=&amp;#34;rawId | formatId&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; ```html
&amp;lt;!DOCTYPE html&amp;gt;
Vue 测试实例
&amp;lt;/head&amp;gt;
{{ message | capitalize }}
  new Vue({ el: &#39;#app&#39;, data: { message: &#39;runoob&#39; }, filters: { capitalize: function (value) { if (!</description>
    </item>
    
    <item>
      <title>Zookeeper学习笔记</title>
      <link>https://linjinbao.github.io/2019/2019-06-17-zookeeper/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-06-17-zookeeper/</guid>
      <description>zookeeper配置 下载地址 http://mirrors.hust.edu.cn/apache/zookeeper/
安装：解压zoo_sample.cfg改为zoo.cfg</description>
    </item>
    
    <item>
      <title>Android学习笔记</title>
      <link>https://linjinbao.github.io/2019/2019-06-11-android/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-06-11-android/</guid>
      <description>Android学习 ListView package com.amrom.linjinbao.listviewtest;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.Toast;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity {private String[] data = {&amp;#34;Apple&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Apple&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Apple&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Apple&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Apple&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;,&amp;#34;Apple&amp;#34;,&amp;#34;Banana&amp;#34;, &amp;#34;Orange&amp;#34;,&amp;#34;WaterMan&amp;#34;,&amp;#34;Pear&amp;#34;};private List&amp;lt;Fruit&amp;gt; fruitList = new ArrayList&amp;lt;&amp;gt;();@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);initFruits();FruitAdapter adapter = new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruitList);ListView listView = (ListView) findViewById(R.</description>
    </item>
    
    <item>
      <title>修复Office文件默认图标</title>
      <link>https://linjinbao.github.io/2019/2019-04-05-%E4%BF%AE%E5%A4%8Doffice%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%9B%BE%E6%A0%87/</link>
      <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://linjinbao.github.io/2019/2019-04-05-%E4%BF%AE%E5%A4%8Doffice%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E5%9B%BE%E6%A0%87/</guid>
      <description>修复office文件默认图标 rem 修复office文件默认图标.bat :: office图标文件路径，请根据自己电脑上的安装目录设置 set officepath=C:\Program Files\Microsoft Office\root\vfs\Windows\Installer\{90160000-000F-0000-1000-0000000FF1CE}\ :: 修复word图标 reg add &amp;#34;HKCR\Word.Document.8\DefaultIcon&amp;#34; /ve /t REG_SZ /d &amp;#34;%officepath%WORDICON.EXE,1&amp;#34; reg delete &amp;#34;HKCR\Word.Document.8\DefaultIcon&amp;#34; /v .ksobak reg add &amp;#34;HKCR\Word.Document.12\DefaultIcon&amp;#34; /ve /t REG_SZ /d &amp;#34;%officepath%WORDICON.EXE,13&amp;#34; :: 此行为删除wps残留注册表文件，下同 reg delete &amp;#34;HKCR\Word.Document.12\DefaultIcon&amp;#34; /v .ksobak :: 修复EXCEL图标 reg add &amp;#34;HKCR\Excel.Sheet.8\DefaultIcon&amp;#34; /ve /t REG_SZ /d &amp;#34;%officepath%XLICONS.EXE,28&amp;#34; reg delete &amp;#34;HKCR\Excel.Sheet.8\DefaultIcon&amp;#34; /v .ksobak reg add &amp;#34;HKCR\Excel.Sheet.12\DefaultIcon&amp;#34; /ve /t REG_SZ /d &amp;#34;%officepath%XLICONS.EXE,1&amp;#34; reg delete &amp;#34;HKCR\Excel.Sheet.12\DefaultIcon&amp;#34; /v .ksobak :: 修复POWERPNT图标 reg add &amp;#34;HKCR\PowerPoint.</description>
    </item>
    
  </channel>
</rss>